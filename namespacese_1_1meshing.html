<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>supereight: se::meshing Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">supereight
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacese.html">se</a></li><li class="navelem"><a class="el" href="namespacese_1_1meshing.html">meshing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">se::meshing Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structse_1_1meshing_1_1Vertex.html">Vertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1meshing_1_1VertexIndexMesh.html">VertexIndexMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a75903044371374f446ae76b7ce6efff8"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a75903044371374f446ae76b7ce6efff8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector3f&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#a75903044371374f446ae76b7ce6efff8">compute_intersection</a> (const OctreeT &amp;octree, const Eigen::Vector3i &amp;coord_0, const Eigen::Vector3i &amp;coord_1)</td></tr>
<tr class="memdesc:a75903044371374f446ae76b7ce6efff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-res marching cube implementation.  <br /></td></tr>
<tr class="separator:a75903044371374f446ae76b7ce6efff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f128d1375afcb739bbb925251087ba"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a45f128d1375afcb739bbb925251087ba"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector3f&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#a45f128d1375afcb739bbb925251087ba">interp_vertexes</a> (const OctreeT &amp;octree, const int x, const int y, const int z, const int edge)</td></tr>
<tr class="separator:a45f128d1375afcb739bbb925251087ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51219f48fd738e12ecc00c9782cbfa91"><td class="memTemplParams" colspan="2">template&lt;typename BlockT &gt; </td></tr>
<tr class="memitem:a51219f48fd738e12ecc00c9782cbfa91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#a51219f48fd738e12ecc00c9782cbfa91">gather_data</a> (const BlockT *block, typename BlockT::DataType data[8], const int x, const int y, const int z)</td></tr>
<tr class="separator:a51219f48fd738e12ecc00c9782cbfa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74748751b9006a0b7809a5f3f68d022"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:af74748751b9006a0b7809a5f3f68d022"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#af74748751b9006a0b7809a5f3f68d022">gather_data</a> (const OctreeT &amp;octree, typename OctreeT::DataType data[8], const int x, const int y, const int z)</td></tr>
<tr class="separator:af74748751b9006a0b7809a5f3f68d022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922c2436f394c70d75c10d8af20daabb"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a922c2436f394c70d75c10d8af20daabb"><td class="memTemplItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#a922c2436f394c70d75c10d8af20daabb">compute_index</a> (const OctreeT &amp;octree, const typename OctreeT::BlockType *block_ptr, const int x, const int y, const int z)</td></tr>
<tr class="separator:a922c2436f394c70d75c10d8af20daabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d839e8d303be7df9b16afb1ccc5f77"><td class="memTemplParams" colspan="2">template&lt;typename DataT &gt; </td></tr>
<tr class="memitem:ac5d839e8d303be7df9b16afb1ccc5f77"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector3f&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#ac5d839e8d303be7df9b16afb1ccc5f77">compute_dual_intersection</a> (const DataT &amp;data_0, const DataT &amp;data_1, const Eigen::Vector3f &amp;dual_point_0_M, const Eigen::Vector3f &amp;dual_point_1_M)</td></tr>
<tr class="memdesc:ac5d839e8d303be7df9b16afb1ccc5f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multires-res marching cube implementation.  <br /></td></tr>
<tr class="separator:ac5d839e8d303be7df9b16afb1ccc5f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ba3ff2bb3c5b945c886f0854c4f260"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename ValueSelector &gt; </td></tr>
<tr class="memitem:aa5ba3ff2bb3c5b945c886f0854c4f260"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector3f&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#aa5ba3ff2bb3c5b945c886f0854c4f260">interp_dual_vertexes</a> (const int edge, const DataT data[8], const std::array&lt; Eigen::Vector3f, 8 &gt; &amp;dual_corner_coords_f)</td></tr>
<tr class="separator:aa5ba3ff2bb3c5b945c886f0854c4f260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d946aa21cab9728a976e4c4eab0da7"><td class="memTemplParams" colspan="2">template&lt;typename BlockT , typename DataT &gt; </td></tr>
<tr class="memitem:a02d946aa21cab9728a976e4c4eab0da7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#a02d946aa21cab9728a976e4c4eab0da7">gather_dual_data</a> (const BlockT *block, const int scale, const Eigen::Vector3f &amp;primal_corner_coord_f, DataT data[8], std::array&lt; Eigen::Vector3f, 8 &gt; &amp;dual_corner_coords_f, std::array&lt; Eigen::Vector3i, 8 &gt; &amp;dual_corner_coords_i)</td></tr>
<tr class="separator:a02d946aa21cab9728a976e4c4eab0da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc254de1e849b4177a56abade0b5935a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#afc254de1e849b4177a56abade0b5935a">norm_dual_corner_idxs</a> (const Eigen::Vector3i &amp;primal_corner_coord_rel, const int block_size, <a class="el" href="namespacese.html#a019e23484e056ce00f3445e0ce853b15">BoundedVector</a>&lt; int, 8 &gt; &amp;lower_priority_neighbours, <a class="el" href="namespacese.html#a019e23484e056ce00f3445e0ce853b15">BoundedVector</a>&lt; int, 8 &gt; &amp;higher_priority_neighbours, <a class="el" href="namespacese.html#a019e23484e056ce00f3445e0ce853b15">BoundedVector</a>&lt; <a class="el" href="namespacese.html#a019e23484e056ce00f3445e0ce853b15">BoundedVector</a>&lt; int, 8 &gt;, 8 &gt; &amp;neighbours)</td></tr>
<tr class="memdesc:afc254de1e849b4177a56abade0b5935a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following strategy is derived from I.  <br /></td></tr>
<tr class="separator:afc254de1e849b4177a56abade0b5935a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4643679857eb02721d4a635f92700b6"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT , typename DataT &gt; </td></tr>
<tr class="memitem:aa4643679857eb02721d4a635f92700b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#aa4643679857eb02721d4a635f92700b6">gather_dual_data</a> (const OctreeT &amp;octree, const typename OctreeT::BlockType *block, const int scale, const Eigen::Vector3i &amp;primal_corner_coord, DataT data[8], std::array&lt; Eigen::Vector3f, 8 &gt; &amp;dual_corner_coords_f, std::array&lt; Eigen::Vector3i, 8 &gt; &amp;dual_corner_coords_i)</td></tr>
<tr class="separator:aa4643679857eb02721d4a635f92700b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71f7ac348ab311de5715c3f34506129"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT , typename DataT &gt; </td></tr>
<tr class="memitem:ab71f7ac348ab311de5715c3f34506129"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#ab71f7ac348ab311de5715c3f34506129">compute_dual_index</a> (const OctreeT &amp;octree, const typename OctreeT::BlockType *block_ptr, const int scale, const Eigen::Vector3i &amp;primal_corner_coord, uint8_t &amp;edge_pattern_idx, DataT data[8], std::array&lt; Eigen::Vector3f, 8 &gt; &amp;dual_corner_coords_f, std::array&lt; Eigen::Vector3i, 8 &gt; &amp;dual_corner_coords_i)</td></tr>
<tr class="separator:ab71f7ac348ab311de5715c3f34506129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14634dc3a48a6265e553b458fd6eb51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#ae14634dc3a48a6265e553b458fd6eb51">checkVertex</a> (const Eigen::Vector3f &amp;vertex_M, const float dim)</td></tr>
<tr class="separator:ae14634dc3a48a6265e553b458fd6eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a86e6c4638ae7acd897f630cdf43f5f57"><td class="memItemLeft" align="right" valign="top">static const Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#a86e6c4638ae7acd897f630cdf43f5f57">norm_dual_offset_f</a> [8]</td></tr>
<tr class="separator:a86e6c4638ae7acd897f630cdf43f5f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0681a2760426757aee58e25cdfae2ce1"><td class="memItemLeft" align="right" valign="top">static const Eigen::Vector3i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1meshing.html#a0681a2760426757aee58e25cdfae2ce1">logical_dual_offset</a> [8]</td></tr>
<tr class="separator:a0681a2760426757aee58e25cdfae2ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a75903044371374f446ae76b7ce6efff8" name="a75903044371374f446ae76b7ce6efff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75903044371374f446ae76b7ce6efff8">&#9670;&#160;</a></span>compute_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f se::meshing::compute_intersection </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>coord_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>coord_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-res marching cube implementation. </p>

</div>
</div>
<a id="a45f128d1375afcb739bbb925251087ba" name="a45f128d1375afcb739bbb925251087ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f128d1375afcb739bbb925251087ba">&#9670;&#160;</a></span>interp_vertexes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f se::meshing::interp_vertexes </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51219f48fd738e12ecc00c9782cbfa91" name="a51219f48fd738e12ecc00c9782cbfa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51219f48fd738e12ecc00c9782cbfa91">&#9670;&#160;</a></span>gather_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void se::meshing::gather_data </td>
          <td>(</td>
          <td class="paramtype">const BlockT *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename BlockT::DataType&#160;</td>
          <td class="paramname"><em>data</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af74748751b9006a0b7809a5f3f68d022" name="af74748751b9006a0b7809a5f3f68d022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74748751b9006a0b7809a5f3f68d022">&#9670;&#160;</a></span>gather_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void se::meshing::gather_data </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename OctreeT::DataType&#160;</td>
          <td class="paramname"><em>data</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a922c2436f394c70d75c10d8af20daabb" name="a922c2436f394c70d75c10d8af20daabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922c2436f394c70d75c10d8af20daabb">&#9670;&#160;</a></span>compute_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t se::meshing::compute_index </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename OctreeT::BlockType *&#160;</td>
          <td class="paramname"><em>block_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5d839e8d303be7df9b16afb1ccc5f77" name="ac5d839e8d303be7df9b16afb1ccc5f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d839e8d303be7df9b16afb1ccc5f77">&#9670;&#160;</a></span>compute_dual_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f se::meshing::compute_dual_intersection </td>
          <td>(</td>
          <td class="paramtype">const DataT &amp;&#160;</td>
          <td class="paramname"><em>data_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataT &amp;&#160;</td>
          <td class="paramname"><em>data_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>dual_point_0_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>dual_point_1_M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multires-res marching cube implementation. </p>

</div>
</div>
<a id="aa5ba3ff2bb3c5b945c886f0854c4f260" name="aa5ba3ff2bb3c5b945c886f0854c4f260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ba3ff2bb3c5b945c886f0854c4f260">&#9670;&#160;</a></span>interp_dual_vertexes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , typename ValueSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f se::meshing::interp_dual_vertexes </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataT&#160;</td>
          <td class="paramname"><em>data</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Eigen::Vector3f, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dual_corner_coords_f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02d946aa21cab9728a976e4c4eab0da7" name="a02d946aa21cab9728a976e4c4eab0da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d946aa21cab9728a976e4c4eab0da7">&#9670;&#160;</a></span>gather_dual_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockT , typename DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void se::meshing::gather_dual_data </td>
          <td>(</td>
          <td class="paramtype">const BlockT *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>primal_corner_coord_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataT&#160;</td>
          <td class="paramname"><em>data</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Eigen::Vector3f, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dual_corner_coords_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Eigen::Vector3i, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dual_corner_coords_i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc254de1e849b4177a56abade0b5935a" name="afc254de1e849b4177a56abade0b5935a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc254de1e849b4177a56abade0b5935a">&#9670;&#160;</a></span>norm_dual_corner_idxs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::meshing::norm_dual_corner_idxs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>primal_corner_coord_rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#a019e23484e056ce00f3445e0ce853b15">BoundedVector</a>&lt; int, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_priority_neighbours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#a019e23484e056ce00f3445e0ce853b15">BoundedVector</a>&lt; int, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higher_priority_neighbours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#a019e23484e056ce00f3445e0ce853b15">BoundedVector</a>&lt; <a class="el" href="namespacese.html#a019e23484e056ce00f3445e0ce853b15">BoundedVector</a>&lt; int, 8 &gt;, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbours</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following strategy is derived from I. </p>
<p>Wald, A Simple, General, and GPU Friendly Method for Computing Dual Mesh and Iso-Surfaces of Adaptive Mesh Refinement (AMR) <a class="el" href="structse_1_1Data.html">Data</a>, 2020</p>
<p>We validate the scale of all neighbouring blocks need to access the 8 dual corners for each primal corner For each we compute the dual coordinates for primal coordinates with a relative block offset x,y,z in [0, block_size] Due to the fact that block_size is still contained in the offset (rather than [0, block_size - 1], each primal corner is contained in 1 (inside block), 2 (face), 4 (edge) or 8 (corner) neighbouring blocks. We prioritse the block neighbours based on their value (heigher value = higher priority), where the value is calculated via v = 4 &lt;&lt; (x is +1) + 2 &lt;&lt; (y is +1) + 1 &lt;&lt; (z is +1). The minium value is computed for all neighbours for dual corners (c0-8). This means if multiple dual corners fall inside the same neighbouring block we take the minimum value of all the dual corners inside the block. The threshold for populate the lower or higher priority list is the lowest dual corner cost of the corners falling inside the block the relative primal coordinate belongs to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">primal_corner_coord_rel</td><td>relative voxel offset of the primal corner from the block coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>size of a voxel block in voxel units </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower_priority_neighbours</td><td>blocks with lower priority, i.e. will be neglected if scale &gt;= scale neighbour </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">higher_priority_neighbours</td><td>blocks with higher priority, i.e. will only be neglected if scale &gt; scale neighbour </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbours</td><td>vector containing a vector with all corner offsets for a neighbouring block. First index is the main block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4643679857eb02721d4a635f92700b6" name="aa4643679857eb02721d4a635f92700b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4643679857eb02721d4a635f92700b6">&#9670;&#160;</a></span>gather_dual_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT , typename DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void se::meshing::gather_dual_data </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename OctreeT::BlockType *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>primal_corner_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataT&#160;</td>
          <td class="paramname"><em>data</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Eigen::Vector3f, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dual_corner_coords_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Eigen::Vector3i, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dual_corner_coords_i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab71f7ac348ab311de5715c3f34506129" name="ab71f7ac348ab311de5715c3f34506129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71f7ac348ab311de5715c3f34506129">&#9670;&#160;</a></span>compute_dual_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT , typename DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void se::meshing::compute_dual_index </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename OctreeT::BlockType *&#160;</td>
          <td class="paramname"><em>block_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>primal_corner_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>edge_pattern_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataT&#160;</td>
          <td class="paramname"><em>data</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Eigen::Vector3f, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dual_corner_coords_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Eigen::Vector3i, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dual_corner_coords_i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae14634dc3a48a6265e553b458fd6eb51" name="ae14634dc3a48a6265e553b458fd6eb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14634dc3a48a6265e553b458fd6eb51">&#9670;&#160;</a></span>checkVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool se::meshing::checkVertex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vertex_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a86e6c4638ae7acd897f630cdf43f5f57" name="a86e6c4638ae7acd897f630cdf43f5f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e6c4638ae7acd897f630cdf43f5f57">&#9670;&#160;</a></span>norm_dual_offset_f</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3f se::meshing::norm_dual_offset_f[8]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{-1, -1, -1},</div>
<div class="line">                                                      {+1, -1, -1},</div>
<div class="line">                                                      {+1, -1, +1},</div>
<div class="line">                                                      {-1, -1, +1},</div>
<div class="line">                                                      {-1, +1, -1},</div>
<div class="line">                                                      {+1, +1, -1},</div>
<div class="line">                                                      {+1, +1, +1},</div>
<div class="line">                                                      {-1, +1, +1}}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0681a2760426757aee58e25cdfae2ce1" name="a0681a2760426757aee58e25cdfae2ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0681a2760426757aee58e25cdfae2ce1">&#9670;&#160;</a></span>logical_dual_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3i se::meshing::logical_dual_offset[8]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{-1, -1, -1},</div>
<div class="line">                                                       {+0, -1, -1},</div>
<div class="line">                                                       {+0, -1, +0},</div>
<div class="line">                                                       {-1, -1, +0},</div>
<div class="line">                                                       {-1, +0, -1},</div>
<div class="line">                                                       {+0, +0, -1},</div>
<div class="line">                                                       {+0, +0, +0},</div>
<div class="line">                                                       {-1, +0, +0}}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
