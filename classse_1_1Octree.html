<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>supereight: se::Octree&lt; DataT, ResT, BlockSize &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">supereight
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacese.html">se</a></li><li class="navelem"><a class="el" href="classse_1_1Octree.html">Octree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classse_1_1Octree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">se::Octree&lt; DataT, ResT, BlockSize &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The octree data structure containing the map data.  
 <a href="classse_1_1Octree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="octree_8hpp_source.html">octree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a19e3b5f455eaf64f929e5362312c8940"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a19e3b5f455eaf64f929e5362312c8940">Ptr</a></td></tr>
<tr class="separator:a19e3b5f455eaf64f929e5362312c8940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168234bec7fde15d8568c1958fd70075"><td class="memItemLeft" align="right" valign="top">typedef DataT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a168234bec7fde15d8568c1958fd70075">DataType</a></td></tr>
<tr class="separator:a168234bec7fde15d8568c1958fd70075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6835a41fb28d3a0e5f6e0299ef500990"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classse_1_1Node.html">Node</a>&lt; DataT, ResT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a6835a41fb28d3a0e5f6e0299ef500990">NodeType</a></td></tr>
<tr class="separator:a6835a41fb28d3a0e5f6e0299ef500990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d8c67062cb40a1a3bb1117009ccb18"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classse_1_1Block.html">Block</a>&lt; DataT, ResT, BlockSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#ac0d8c67062cb40a1a3bb1117009ccb18">BlockType</a></td></tr>
<tr class="separator:ac0d8c67062cb40a1a3bb1117009ccb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb95da91a3361a8c9f18ab52d6d9148d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacese.html#a187406f01aea17dc759bf3839e3d1909">TriangleMesh</a>&lt; DataT::col_, DataT::sem_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#adb95da91a3361a8c9f18ab52d6d9148d">SurfaceMesh</a></td></tr>
<tr class="separator:adb95da91a3361a8c9f18ab52d6d9148d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d20cc0d44e20c4f9b098d168e5a87b2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacese.html#ac3ec554b5d135b84fae821e8da65fea0">QuadMesh</a>&lt; <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011ad15305d7a4e34e02489c74a5ef542f36">Colour::Off</a>, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68ad15305d7a4e34e02489c74a5ef542f36">Semantics::Off</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a7d20cc0d44e20c4f9b098d168e5a87b2">StructureMesh</a></td></tr>
<tr class="separator:a7d20cc0d44e20c4f9b098d168e5a87b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a165922fe36f11df8bf10aa3f4696be94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a165922fe36f11df8bf10aa3f4696be94">Octree</a> (const int size)</td></tr>
<tr class="memdesc:a165922fe36f11df8bf10aa3f4696be94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an octree with an edge length of at least <code>size</code> voxels.  <br /></td></tr>
<tr class="separator:a165922fe36f11df8bf10aa3f4696be94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2a3cef3ab43d9f9d5463afc0ac3662"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#aaf2a3cef3ab43d9f9d5463afc0ac3662">Octree</a> (const <a class="el" href="classse_1_1Octree.html">Octree</a> &amp;)=delete</td></tr>
<tr class="memdesc:aaf2a3cef3ab43d9f9d5463afc0ac3662"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor is explicitly deleted because copying octrees is expensive.  <br /></td></tr>
<tr class="separator:aaf2a3cef3ab43d9f9d5463afc0ac3662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086e5fb9fe3009273b3927cf2ecec582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1Octree.html">Octree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a086e5fb9fe3009273b3927cf2ecec582">operator=</a> (const <a class="el" href="classse_1_1Octree.html">Octree</a> &amp;)=delete</td></tr>
<tr class="memdesc:a086e5fb9fe3009273b3927cf2ecec582"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy assignment operator is explicitly deleted because copying octrees is expensive.  <br /></td></tr>
<tr class="separator:a086e5fb9fe3009273b3927cf2ecec582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84a752d2d17400c18646a97550b1a06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#ab84a752d2d17400c18646a97550b1a06">begin</a> ()</td></tr>
<tr class="separator:ab84a752d2d17400c18646a97550b1a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecd6cfb64ed384f12bfe8d9cc0c5664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; const <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a9ecd6cfb64ed384f12bfe8d9cc0c5664">begin</a> () const</td></tr>
<tr class="separator:a9ecd6cfb64ed384f12bfe8d9cc0c5664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e0e9b59cfc71132d845a9c05817fd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; const <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a94e0e9b59cfc71132d845a9c05817fd0">cbegin</a> () const</td></tr>
<tr class="separator:a94e0e9b59cfc71132d845a9c05817fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5819847f1a93104c425539524cc043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a5c5819847f1a93104c425539524cc043">end</a> ()</td></tr>
<tr class="separator:a5c5819847f1a93104c425539524cc043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9f1ec42b7620b4d4d52c275a71e166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; const <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a2b9f1ec42b7620b4d4d52c275a71e166">end</a> () const</td></tr>
<tr class="separator:a2b9f1ec42b7620b4d4d52c275a71e166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1ab70306864bcc347b99909ded9191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; const <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a0e1ab70306864bcc347b99909ded9191">cend</a> () const</td></tr>
<tr class="separator:a0e1ab70306864bcc347b99909ded9191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b88a2097c409cfe8d34ca0adc24297"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a58b88a2097c409cfe8d34ca0adc24297">contains</a> (const Eigen::Vector3i &amp;voxel_coord) const</td></tr>
<tr class="memdesc:a58b88a2097c409cfe8d34ca0adc24297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether point <code>voxel_coord</code> with coordinates in voxels is contained in the octree.  <br /></td></tr>
<tr class="separator:a58b88a2097c409cfe8d34ca0adc24297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aafeea2486b08963f17e9c58cb1e45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1OctantBase.html">OctantBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#ae1aafeea2486b08963f17e9c58cb1e45">getRoot</a> ()</td></tr>
<tr class="memdesc:ae1aafeea2486b08963f17e9c58cb1e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-null pointer to the octree's root node.  <br /></td></tr>
<tr class="separator:ae1aafeea2486b08963f17e9c58cb1e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676ee0fbe25e0c8ae2a0fef347299467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1OctantBase.html">OctantBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a676ee0fbe25e0c8ae2a0fef347299467">getRoot</a> () const</td></tr>
<tr class="memdesc:a676ee0fbe25e0c8ae2a0fef347299467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const version of <a class="el" href="classse_1_1Octree.html#ae1aafeea2486b08963f17e9c58cb1e45" title="Return a non-null pointer to the octree&#39;s root node.">se::Octree::getRoot()</a>.  <br /></td></tr>
<tr class="separator:a676ee0fbe25e0c8ae2a0fef347299467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb5020c56a6187436e72308e54e77b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a7cb5020c56a6187436e72308e54e77b4">getSize</a> () const</td></tr>
<tr class="memdesc:a7cb5020c56a6187436e72308e54e77b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the edge length of the octree volume in voxels.  <br /></td></tr>
<tr class="separator:a7cb5020c56a6187436e72308e54e77b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1453c4d140abbaef1a55098ec75dfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a3a1453c4d140abbaef1a55098ec75dfc">getMaxScale</a> () const</td></tr>
<tr class="memdesc:a3a1453c4d140abbaef1a55098ec75dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum octree scale, that is, the scale of the root node.  <br /></td></tr>
<tr class="separator:a3a1453c4d140abbaef1a55098ec75dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907f097fadf42b1735adfaec316cc85d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a907f097fadf42b1735adfaec316cc85d">getBlockDepth</a> () const</td></tr>
<tr class="memdesc:a907f097fadf42b1735adfaec316cc85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the depth blocks are allocated at.  <br /></td></tr>
<tr class="separator:a907f097fadf42b1735adfaec316cc85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3d5f5fa444a9051b1826ecc4417410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1Octree.html#adb95da91a3361a8c9f18ab52d6d9148d">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#abd3d5f5fa444a9051b1826ecc4417410">mesh</a> (const Eigen::Affine3f &amp;T_OV=Eigen::Affine3f::Identity(), const int min_desired_scale=0) const</td></tr>
<tr class="memdesc:abd3d5f5fa444a9051b1826ecc4417410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mesh of the reconstructed surface in the octree frame in units of voxels.  <br /></td></tr>
<tr class="separator:abd3d5f5fa444a9051b1826ecc4417410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faedb86b31746812be223bf453b16e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a2faedb86b31746812be223bf453b16e8">saveMesh</a> (const std::string &amp;filename, const Eigen::Affine3f &amp;T_OV=Eigen::Affine3f::Identity(), const int min_desired_scale=0) const</td></tr>
<tr class="memdesc:a2faedb86b31746812be223bf453b16e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the mesh returned by <a class="el" href="classse_1_1Octree.html#abd3d5f5fa444a9051b1826ecc4417410" title="Return a mesh of the reconstructed surface in the octree frame in units of voxels.">se::Octree::mesh()</a> in <code>filename</code>.  <br /></td></tr>
<tr class="separator:a2faedb86b31746812be223bf453b16e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c37fb63fbf74b8da7123cb11d0f4e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1Octree.html#a7d20cc0d44e20c4f9b098d168e5a87b2">StructureMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a4c37fb63fbf74b8da7123cb11d0f4e86">structure</a> (const Eigen::Affine3f &amp;T_OV=Eigen::Affine3f::Identity(), const bool only_leaves=true) const</td></tr>
<tr class="memdesc:a4c37fb63fbf74b8da7123cb11d0f4e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mesh of the octree structure in the octree frame in units of voxels.  <br /></td></tr>
<tr class="separator:a4c37fb63fbf74b8da7123cb11d0f4e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee6f8da97a345c7d3e32b9ebf400894"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a8ee6f8da97a345c7d3e32b9ebf400894">saveStructure</a> (const std::string &amp;filename, const Eigen::Affine3f &amp;T_OV=Eigen::Affine3f::Identity(), const bool only_leaves=true) const</td></tr>
<tr class="memdesc:a8ee6f8da97a345c7d3e32b9ebf400894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the mesh returned by <a class="el" href="classse_1_1Octree.html#a4c37fb63fbf74b8da7123cb11d0f4e86" title="Return a mesh of the octree structure in the octree frame in units of voxels.">se::Octree::structure()</a> in <code>filename</code>.  <br /></td></tr>
<tr class="separator:a8ee6f8da97a345c7d3e32b9ebf400894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a39e6d0f53f7875f99f7b37c68040a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a4a39e6d0f53f7875f99f7b37c68040a8">allocate</a> (<a class="el" href="classse_1_1Octree.html#a6835a41fb28d3a0e5f6e0299ef500990">NodeType</a> *const parent_ptr, const int child_idx, <a class="el" href="classse_1_1OctantBase.html">OctantBase</a> *&amp;child_ptr)</td></tr>
<tr class="memdesc:a4a39e6d0f53f7875f99f7b37c68040a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a child of a node.  <br /></td></tr>
<tr class="separator:a4a39e6d0f53f7875f99f7b37c68040a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab149aa19bfb289d1f5542b0f5d1ce52c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#ab149aa19bfb289d1f5542b0f5d1ce52c">allocateChildren</a> (<a class="el" href="classse_1_1Octree.html#a6835a41fb28d3a0e5f6e0299ef500990">NodeType</a> *const parent_ptr)</td></tr>
<tr class="memdesc:ab149aa19bfb289d1f5542b0f5d1ce52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate all the children of <code>parent_ptr</code>.  <br /></td></tr>
<tr class="separator:ab149aa19bfb289d1f5542b0f5d1ce52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9015d6936c5bbe458b4868771e56cf81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a9015d6936c5bbe458b4868771e56cf81">deleteChildren</a> (<a class="el" href="classse_1_1Octree.html#a6835a41fb28d3a0e5f6e0299ef500990">NodeType</a> *const parent_ptr)</td></tr>
<tr class="memdesc:a9015d6936c5bbe458b4868771e56cf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively delete all the children of <code>parent_ptr</code>.  <br /></td></tr>
<tr class="separator:a9015d6936c5bbe458b4868771e56cf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575152823c1c0e8a82ef278b9aa4cc45"><td class="memItemLeft" align="right" valign="top">const Eigen::AlignedBox3i &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a575152823c1c0e8a82ef278b9aa4cc45">aabb</a> () const</td></tr>
<tr class="memdesc:a575152823c1c0e8a82ef278b9aa4cc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the axis-aligned bounding box of the octree's allocated leaves.  <br /></td></tr>
<tr class="separator:a575152823c1c0e8a82ef278b9aa4cc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac580677ce9f98f11530e3c8f82e715d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#aac580677ce9f98f11530e3c8f82e715d">aabbExtend</a> (const Eigen::Vector3i &amp;voxel_coord, const int size)</td></tr>
<tr class="memdesc:aac580677ce9f98f11530e3c8f82e715d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the octree allocated leaf AABB to contain the octant with coordinates in voxels <code>voxel_coord</code> and edge length in voxels <code>size</code>.  <br /></td></tr>
<tr class="separator:aac580677ce9f98f11530e3c8f82e715d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab2b9023d32cfd1e6d58feba18f29c087"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#ab2b9023d32cfd1e6d58feba18f29c087">fld_</a> = DataT::fld_</td></tr>
<tr class="separator:ab2b9023d32cfd1e6d58feba18f29c087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aa486ad184e360e9e4e9ea338313e5"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#ab3aa486ad184e360e9e4e9ea338313e5">col_</a> = DataT::col_</td></tr>
<tr class="separator:ab3aa486ad184e360e9e4e9ea338313e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ed0c6ae8aa85cc5ad9231bb394d9f3"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a79ed0c6ae8aa85cc5ad9231bb394d9f3">sem_</a> = DataT::sem_</td></tr>
<tr class="separator:a79ed0c6ae8aa85cc5ad9231bb394d9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ddb790a74441af4cd6a7ebfc9d065a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#a07ddb790a74441af4cd6a7ebfc9d065a">res_</a> = ResT</td></tr>
<tr class="separator:a07ddb790a74441af4cd6a7ebfc9d065a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb839757ead22c11701cf2443aa2209c"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#aeb839757ead22c11701cf2443aa2209c">block_size</a> = BlockSize</td></tr>
<tr class="memdesc:aeb839757ead22c11701cf2443aa2209c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge length of a block in voxels.  <br /></td></tr>
<tr class="separator:aeb839757ead22c11701cf2443aa2209c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27aa41c3626ac538d4d4867a8020d39"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">scale_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Octree.html#ac27aa41c3626ac538d4d4867a8020d39">max_block_scale</a> = <a class="el" href="namespacese_1_1octantops.html#a8033b4391b8eb4594c35277e87abb31e">octantops::size_to_scale</a>(BlockSize)</td></tr>
<tr class="memdesc:ac27aa41c3626ac538d4d4867a8020d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum scale of a block.  <br /></td></tr>
<tr class="separator:ac27aa41c3626ac538d4d4867a8020d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename DataT, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt;<br />
class se::Octree&lt; DataT, ResT, BlockSize &gt;</div><p>The octree data structure containing the map data. </p>
<p>It is the memory manager of the map since it is the only entity that is able to allocate and deallocate nodes and blocks. There are specialized functions and classes for accessing (<a class="el" href="namespacese_1_1visitor.html">se::visitor</a>) and modifying (<a class="el" href="classse_1_1MapIntegrator.html">se::MapIntegrator</a>) the map data as this isn't done through this class. At the maximum octree depth data is stored in blocks of <code>BlockSize<sup>3</sup></code> voxels.</p>
<p><a href="https://en.wikipedia.org/wiki/Octree">https://en.wikipedia.org/wiki/Octree</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataT</td><td>The data type stored in the octree. </td></tr>
    <tr><td class="paramname">ResT</td><td><a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">se::Res::Single</a> if data is only stored in the octree leaves or <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">se::Res::Multi</a> if data is stored in all octree nodes. </td></tr>
    <tr><td class="paramname">BlockSize</td><td>The edge length of a voxel block in voxels. It must be a power of two. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a19e3b5f455eaf64f929e5362312c8940" name="a19e3b5f455eaf64f929e5362312c8940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e3b5f455eaf64f929e5362312c8940">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classse_1_1Octree.html">Octree</a>&lt;DataT, ResT, BlockSize&gt; &gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::Ptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a168234bec7fde15d8568c1958fd70075" name="a168234bec7fde15d8568c1958fd70075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168234bec7fde15d8568c1958fd70075">&#9670;&#160;</a></span>DataType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DataT <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::DataType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6835a41fb28d3a0e5f6e0299ef500990" name="a6835a41fb28d3a0e5f6e0299ef500990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6835a41fb28d3a0e5f6e0299ef500990">&#9670;&#160;</a></span>NodeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classse_1_1Node.html">Node</a>&lt;DataT, ResT&gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::NodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0d8c67062cb40a1a3bb1117009ccb18" name="ac0d8c67062cb40a1a3bb1117009ccb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d8c67062cb40a1a3bb1117009ccb18">&#9670;&#160;</a></span>BlockType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classse_1_1Block.html">Block</a>&lt;DataT, ResT, BlockSize&gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::BlockType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb95da91a3361a8c9f18ab52d6d9148d" name="adb95da91a3361a8c9f18ab52d6d9148d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb95da91a3361a8c9f18ab52d6d9148d">&#9670;&#160;</a></span>SurfaceMesh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacese.html#a187406f01aea17dc759bf3839e3d1909">TriangleMesh</a>&lt;DataT::col_, DataT::sem_&gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::SurfaceMesh</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d20cc0d44e20c4f9b098d168e5a87b2" name="a7d20cc0d44e20c4f9b098d168e5a87b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d20cc0d44e20c4f9b098d168e5a87b2">&#9670;&#160;</a></span>StructureMesh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacese.html#ac3ec554b5d135b84fae821e8da65fea0">QuadMesh</a>&lt;<a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011ad15305d7a4e34e02489c74a5ef542f36">Colour::Off</a>, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68ad15305d7a4e34e02489c74a5ef542f36">Semantics::Off</a>&gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::StructureMesh</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a165922fe36f11df8bf10aa3f4696be94" name="a165922fe36f11df8bf10aa3f4696be94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165922fe36f11df8bf10aa3f4696be94">&#9670;&#160;</a></span>Octree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::Octree </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an octree with an edge length of at least <code>size</code> voxels. </p>
<p>The actual edge length in voxels, as returned by <a class="el" href="classse_1_1Octree.html#a7cb5020c56a6187436e72308e54e77b4" title="Return the edge length of the octree volume in voxels.">se::Octree::getSize()</a>, will be the smallest power of 2 that at least <code>size</code> and at least <code>2 * BlockSize</code>. </p>

</div>
</div>
<a id="aaf2a3cef3ab43d9f9d5463afc0ac3662" name="aaf2a3cef3ab43d9f9d5463afc0ac3662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2a3cef3ab43d9f9d5463afc0ac3662">&#9670;&#160;</a></span>Octree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::Octree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor is explicitly deleted because copying octrees is expensive. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a086e5fb9fe3009273b3927cf2ecec582" name="a086e5fb9fe3009273b3927cf2ecec582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086e5fb9fe3009273b3927cf2ecec582">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Octree.html">Octree</a> &amp; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy assignment operator is explicitly deleted because copying octrees is expensive. </p>

</div>
</div>
<a id="ab84a752d2d17400c18646a97550b1a06" name="ab84a752d2d17400c18646a97550b1a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84a752d2d17400c18646a97550b1a06">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ecd6cfb64ed384f12bfe8d9cc0c5664" name="a9ecd6cfb64ed384f12bfe8d9cc0c5664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecd6cfb64ed384f12bfe8d9cc0c5664">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; const <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94e0e9b59cfc71132d845a9c05817fd0" name="a94e0e9b59cfc71132d845a9c05817fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e0e9b59cfc71132d845a9c05817fd0">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; const <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c5819847f1a93104c425539524cc043" name="a5c5819847f1a93104c425539524cc043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5819847f1a93104c425539524cc043">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b9f1ec42b7620b4d4d52c275a71e166" name="a2b9f1ec42b7620b4d4d52c275a71e166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9f1ec42b7620b4d4d52c275a71e166">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; const <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e1ab70306864bcc347b99909ded9191" name="a0e1ab70306864bcc347b99909ded9191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1ab70306864bcc347b99909ded9191">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structse_1_1OctreeIterator.html">OctreeIterator</a>&lt; const <a class="el" href="classse_1_1Octree.html">Octree</a>&lt; DataT, ResT, BlockSize &gt; &gt; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58b88a2097c409cfe8d34ca0adc24297" name="a58b88a2097c409cfe8d34ca0adc24297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b88a2097c409cfe8d34ca0adc24297">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether point <code>voxel_coord</code> with coordinates in voxels is contained in the octree. </p>

</div>
</div>
<a id="ae1aafeea2486b08963f17e9c58cb1e45" name="ae1aafeea2486b08963f17e9c58cb1e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aafeea2486b08963f17e9c58cb1e45">&#9670;&#160;</a></span>getRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1OctantBase.html">OctantBase</a> * <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a non-null pointer to the octree's root node. </p>

</div>
</div>
<a id="a676ee0fbe25e0c8ae2a0fef347299467" name="a676ee0fbe25e0c8ae2a0fef347299467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676ee0fbe25e0c8ae2a0fef347299467">&#9670;&#160;</a></span>getRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1OctantBase.html">OctantBase</a> * <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const version of <a class="el" href="classse_1_1Octree.html#ae1aafeea2486b08963f17e9c58cb1e45" title="Return a non-null pointer to the octree&#39;s root node.">se::Octree::getRoot()</a>. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Return <code>const OctantBase*</code> once a proper const iterator is implemented. </dd></dl>

</div>
</div>
<a id="a7cb5020c56a6187436e72308e54e77b4" name="a7cb5020c56a6187436e72308e54e77b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb5020c56a6187436e72308e54e77b4">&#9670;&#160;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the edge length of the octree volume in voxels. </p>

</div>
</div>
<a id="a3a1453c4d140abbaef1a55098ec75dfc" name="a3a1453c4d140abbaef1a55098ec75dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1453c4d140abbaef1a55098ec75dfc">&#9670;&#160;</a></span>getMaxScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::getMaxScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum octree scale, that is, the scale of the root node. </p>

</div>
</div>
<a id="a907f097fadf42b1735adfaec316cc85d" name="a907f097fadf42b1735adfaec316cc85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907f097fadf42b1735adfaec316cc85d">&#9670;&#160;</a></span>getBlockDepth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::getBlockDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the depth blocks are allocated at. </p>

</div>
</div>
<a id="abd3d5f5fa444a9051b1826ecc4417410" name="abd3d5f5fa444a9051b1826ecc4417410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3d5f5fa444a9051b1826ecc4417410">&#9670;&#160;</a></span>mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Octree.html#adb95da91a3361a8c9f18ab52d6d9148d">SurfaceMesh</a> <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>T_OV</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_desired_scale</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mesh of the reconstructed surface in the octree frame in units of voxels. </p>
<p>Apply a transformation, from the octree frame V to some output frame O, <code>T_OV</code> to each mesh vertex. For <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">se::Res::Multi</a> maps, only data at scale <code>min_desired_scale</code> or coarser will be used to generate the mesh. This allows generating a coarser mesh which is less demanding in terms of computational time and memory. The value of <code>min_desired_scale</code> has no effect on <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">se::Res::Single</a> maps. </p>

</div>
</div>
<a id="a2faedb86b31746812be223bf453b16e8" name="a2faedb86b31746812be223bf453b16e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2faedb86b31746812be223bf453b16e8">&#9670;&#160;</a></span>saveMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::saveMesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>T_OV</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_desired_scale</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the mesh returned by <a class="el" href="classse_1_1Octree.html#abd3d5f5fa444a9051b1826ecc4417410" title="Return a mesh of the reconstructed surface in the octree frame in units of voxels.">se::Octree::mesh()</a> in <code>filename</code>. </p>
<p>The <code>T_OV</code> and <code>min_desired_scale</code> arguments are passed directly to <a class="el" href="classse_1_1Octree.html#abd3d5f5fa444a9051b1826ecc4417410" title="Return a mesh of the reconstructed surface in the octree frame in units of voxels.">se::Octree::mesh()</a>. The file format will be selected based on the extension of <code>filename</code>, which must be one of those in <a class="el" href="namespacese_1_1io.html#a2fa055ecd523d1c81f7f90bd36bb0095" title="The supported file extensions for mesh files.">se::io::mesh_extensions</a>. Return the value returned by <a class="el" href="namespacese_1_1io.html#a85fc2a41c10704ff9ab85615cd895b05" title="Save a mesh to a file whose type is determined by the extension of filename.">se::io::save_mesh()</a>. </p>

</div>
</div>
<a id="a4c37fb63fbf74b8da7123cb11d0f4e86" name="a4c37fb63fbf74b8da7123cb11d0f4e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c37fb63fbf74b8da7123cb11d0f4e86">&#9670;&#160;</a></span>structure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Octree.html#a7d20cc0d44e20c4f9b098d168e5a87b2">StructureMesh</a> <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::structure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>T_OV</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>only_leaves</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mesh of the octree structure in the octree frame in units of voxels. </p>
<p>Apply a transformation, from the octree frame V to some output frame O, <code>T_OV</code> to each mesh vertex. The returned mesh will only contain leaf octants if <code>only_leaves</code> is true. </p>

</div>
</div>
<a id="a8ee6f8da97a345c7d3e32b9ebf400894" name="a8ee6f8da97a345c7d3e32b9ebf400894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee6f8da97a345c7d3e32b9ebf400894">&#9670;&#160;</a></span>saveStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::saveStructure </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>T_OV</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>only_leaves</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the mesh returned by <a class="el" href="classse_1_1Octree.html#a4c37fb63fbf74b8da7123cb11d0f4e86" title="Return a mesh of the octree structure in the octree frame in units of voxels.">se::Octree::structure()</a> in <code>filename</code>. </p>
<p>The <code>T_OV</code> and <code>only_leaves</code> arguments are passed directly to <a class="el" href="classse_1_1Octree.html#a4c37fb63fbf74b8da7123cb11d0f4e86" title="Return a mesh of the octree structure in the octree frame in units of voxels.">se::Octree::structure()</a>. The file format will be selected based on the extension of <code>filename</code>, which must be one of those in <a class="el" href="namespacese_1_1io.html#a2fa055ecd523d1c81f7f90bd36bb0095" title="The supported file extensions for mesh files.">se::io::mesh_extensions</a>. Return the value returned by <a class="el" href="namespacese_1_1io.html#a85fc2a41c10704ff9ab85615cd895b05" title="Save a mesh to a file whose type is determined by the extension of filename.">se::io::save_mesh()</a>. </p>

</div>
</div>
<a id="a4a39e6d0f53f7875f99f7b37c68040a8" name="a4a39e6d0f53f7875f99f7b37c68040a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a39e6d0f53f7875f99f7b37c68040a8">&#9670;&#160;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classse_1_1Octree.html#a6835a41fb28d3a0e5f6e0299ef500990">NodeType</a> *const&#160;</td>
          <td class="paramname"><em>parent_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>child_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classse_1_1OctantBase.html">OctantBase</a> *&amp;&#160;</td>
          <td class="paramname"><em>child_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a child of a node. </p>
<dl class="section note"><dt>Note</dt><dd>The returned pointer is of type <a class="el" href="classse_1_1OctantBase.html" title="The base class of all octants (se::Node and se::Block) in an se::Octree.">se::OctantBase</a> as the child might be a node or block.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function might be dangerous when using Multires Occupancy. Use <a class="el" href="classse_1_1Octree.html#ab149aa19bfb289d1f5542b0f5d1ce52c" title="Allocate all the children of parent_ptr.">se::Octree::allocateChildren()</a> if unsure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_ptr</td><td>The parent of the octant to be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child_idx</td><td>The child index of the octant to be allocated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">child_ptr</td><td>The pointer to the allocated or fetched octant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the child was allocated, false if it was already allocated. </dd></dl>

</div>
</div>
<a id="ab149aa19bfb289d1f5542b0f5d1ce52c" name="ab149aa19bfb289d1f5542b0f5d1ce52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab149aa19bfb289d1f5542b0f5d1ce52c">&#9670;&#160;</a></span>allocateChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::allocateChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classse_1_1Octree.html#a6835a41fb28d3a0e5f6e0299ef500990">NodeType</a> *const&#160;</td>
          <td class="paramname"><em>parent_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate all the children of <code>parent_ptr</code>. </p>

</div>
</div>
<a id="a9015d6936c5bbe458b4868771e56cf81" name="a9015d6936c5bbe458b4868771e56cf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9015d6936c5bbe458b4868771e56cf81">&#9670;&#160;</a></span>deleteChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::deleteChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classse_1_1Octree.html#a6835a41fb28d3a0e5f6e0299ef500990">NodeType</a> *const&#160;</td>
          <td class="paramname"><em>parent_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively delete all the children of <code>parent_ptr</code>. </p>

</div>
</div>
<a id="a575152823c1c0e8a82ef278b9aa4cc45" name="a575152823c1c0e8a82ef278b9aa4cc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575152823c1c0e8a82ef278b9aa4cc45">&#9670;&#160;</a></span>aabb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::AlignedBox3i &amp; <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::aabb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the axis-aligned bounding box of the octree's allocated leaves. </p>
<p>The bounding box is computed using the coordinates of allocated voxels, not using the whole allocated volume. Thus the coordinates of its vertices are in the interval [0, <a class="el" href="classse_1_1Octree.html#a7cb5020c56a6187436e72308e54e77b4" title="Return the edge length of the octree volume in voxels.">se::Octree::getSize()</a>) and it can be used to safely test if some voxel is contained in it using Eigen::AlignedBox3i::contains(). </p>

</div>
</div>
<a id="aac580677ce9f98f11530e3c8f82e715d" name="aac580677ce9f98f11530e3c8f82e715d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac580677ce9f98f11530e3c8f82e715d">&#9670;&#160;</a></span>aabbExtend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::aabbExtend </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend the octree allocated leaf AABB to contain the octant with coordinates in voxels <code>voxel_coord</code> and edge length in voxels <code>size</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This is typically only needed to update the AABB with leaf nodes as they can't efficiently be detected during allocation since all nodes are leaves when allocated. This function should be called only for newly allocated leaf nodes from an allocator that allocates free nodes (e.g. <a class="el" href="classse_1_1VolumeCarver.html" title="Unimplemented on purpose so that the template specialization is used.">se::VolumeCarver</a>). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab2b9023d32cfd1e6d58feba18f29c087" name="ab2b9023d32cfd1e6d58feba18f29c087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b9023d32cfd1e6d58feba18f29c087">&#9670;&#160;</a></span>fld_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::fld_ = DataT::fld_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3aa486ad184e360e9e4e9ea338313e5" name="ab3aa486ad184e360e9e4e9ea338313e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3aa486ad184e360e9e4e9ea338313e5">&#9670;&#160;</a></span>col_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::col_ = DataT::col_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79ed0c6ae8aa85cc5ad9231bb394d9f3" name="a79ed0c6ae8aa85cc5ad9231bb394d9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ed0c6ae8aa85cc5ad9231bb394d9f3">&#9670;&#160;</a></span>sem_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::sem_ = DataT::sem_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07ddb790a74441af4cd6a7ebfc9d065a" name="a07ddb790a74441af4cd6a7ebfc9d065a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ddb790a74441af4cd6a7ebfc9d065a">&#9670;&#160;</a></span>res_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::res_ = ResT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb839757ead22c11701cf2443aa2209c" name="aeb839757ead22c11701cf2443aa2209c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb839757ead22c11701cf2443aa2209c">&#9670;&#160;</a></span>block_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::block_size = BlockSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The edge length of a block in voxels. </p>

</div>
</div>
<a id="ac27aa41c3626ac538d4d4867a8020d39" name="ac27aa41c3626ac538d4d4867a8020d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27aa41c3626ac538d4d4867a8020d39">&#9670;&#160;</a></span>max_block_scale</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT = Res::Single, int BlockSize = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">scale_t</a> <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; DataT, ResT, BlockSize &gt;::max_block_scale = <a class="el" href="namespacese_1_1octantops.html#a8033b4391b8eb4594c35277e87abb31e">octantops::size_to_scale</a>(BlockSize)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum scale of a block. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/se/map/octree/<a class="el" href="octree_8hpp_source.html">octree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
