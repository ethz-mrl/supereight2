<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>supereight: se::Map&lt; se::Data&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">supereight
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacese.html">se</a></li><li class="navelem"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html">Map&lt; se::Data&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">se::Map&lt; se::Data&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="map_8hpp_source.html">map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4_1_1Config.html">Config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaf6ffffacbdcfc1d8e9dd09d67c66e0f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structse_1_1Data.html">Data</a>&lt; FldT, ColB, SemB &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a></td></tr>
<tr class="separator:aaf6ffffacbdcfc1d8e9dd09d67c66e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f55bfb211664276b34c0f18463a87e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structse_1_1Data.html">Data</a>&lt; FldT, ColB, SemB &gt;::Config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ad9f55bfb211664276b34c0f18463a87e">DataConfigType</a></td></tr>
<tr class="separator:ad9f55bfb211664276b34c0f18463a87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ce519441156a1fb5f47857ed8a7580"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt; <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a>, ResT, BlockSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aa8ce519441156a1fb5f47857ed8a7580">OctreeType</a></td></tr>
<tr class="separator:aa8ce519441156a1fb5f47857ed8a7580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0c3fe0efa991c1a62521aa29a88369"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classse_1_1Octree.html#adb95da91a3361a8c9f18ab52d6d9148d">OctreeType::SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aac0c3fe0efa991c1a62521aa29a88369">SurfaceMesh</a></td></tr>
<tr class="separator:aac0c3fe0efa991c1a62521aa29a88369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bfa1efd611864f3140bbbd3173b512"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classse_1_1Octree.html#a7d20cc0d44e20c4f9b098d168e5a87b2">OctreeType::StructureMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#af6bfa1efd611864f3140bbbd3173b512">StructureMesh</a></td></tr>
<tr class="separator:af6bfa1efd611864f3140bbbd3173b512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac47ed9cb24673e5e9262eed247e61295"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ac47ed9cb24673e5e9262eed247e61295">Map</a> (const Eigen::Vector3f &amp;dim, const float res, const typename <a class="el" href="structse_1_1Data.html">Data</a>&lt; FldT, ColB, SemB &gt;::Config &amp;data_config=typename <a class="el" href="structse_1_1Data.html">Data</a>&lt; FldT, ColB, SemB &gt;::Config())</td></tr>
<tr class="memdesc:ac47ed9cb24673e5e9262eed247e61295"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map constructor.  <br /></td></tr>
<tr class="separator:ac47ed9cb24673e5e9262eed247e61295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5ee3b594d3de916a25d76d6f055774"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a4e5ee3b594d3de916a25d76d6f055774">Map</a> (const <a class="el" href="structse_1_1Config.html">Config</a> &amp;map_config, const typename <a class="el" href="structse_1_1Data.html">Data</a>&lt; FldT, ColB, SemB &gt;::Config &amp;data_config=typename <a class="el" href="structse_1_1Data.html">Data</a>&lt; FldT, ColB, SemB &gt;::Config())</td></tr>
<tr class="memdesc:a4e5ee3b594d3de916a25d76d6f055774"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map constructor.  <br /></td></tr>
<tr class="separator:a4e5ee3b594d3de916a25d76d6f055774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d574f583c45cf408da6250056b064e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a55d574f583c45cf408da6250056b064e">Map</a> (const <a class="el" href="classse_1_1Map.html">Map</a> &amp;)=delete</td></tr>
<tr class="memdesc:a55d574f583c45cf408da6250056b064e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor is explicitly deleted.  <br /></td></tr>
<tr class="separator:a55d574f583c45cf408da6250056b064e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4233091867e74ac27cd8de487653a605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1Map.html">Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a4233091867e74ac27cd8de487653a605">operator=</a> (const <a class="el" href="classse_1_1Map.html">Map</a> &amp;)=delete</td></tr>
<tr class="memdesc:a4233091867e74ac27cd8de487653a605"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy assignment operator is explicitly deleted.  <br /></td></tr>
<tr class="separator:a4233091867e74ac27cd8de487653a605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfb0229678799eea0eb87d5d9f82024"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a1bfb0229678799eea0eb87d5d9f82024">contains</a> (const Eigen::Vector3f &amp;point_W) const</td></tr>
<tr class="memdesc:a1bfb0229678799eea0eb87d5d9f82024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if a point is inside the map.  <br /></td></tr>
<tr class="separator:a1bfb0229678799eea0eb87d5d9f82024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e771a71c068d985017b8c6398952c7e"><td class="memItemLeft" align="right" valign="top">const Eigen::Isometry3f &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a9e771a71c068d985017b8c6398952c7e">getTMW</a> () const</td></tr>
<tr class="memdesc:a9e771a71c068d985017b8c6398952c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation from world to map frame.  <br /></td></tr>
<tr class="separator:a9e771a71c068d985017b8c6398952c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46301ef15afe4d0c6822f9ae1a3830a"><td class="memItemLeft" align="right" valign="top">const Eigen::Isometry3f &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#af46301ef15afe4d0c6822f9ae1a3830a">getTWM</a> () const</td></tr>
<tr class="memdesc:af46301ef15afe4d0c6822f9ae1a3830a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation from map to world frame.  <br /></td></tr>
<tr class="separator:af46301ef15afe4d0c6822f9ae1a3830a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f601dc216b1e0e8a09927fc156c94eb"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3f &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a3f601dc216b1e0e8a09927fc156c94eb">getDim</a> () const</td></tr>
<tr class="memdesc:a3f601dc216b1e0e8a09927fc156c94eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensions of the map in [meter] (length x width x height)  <br /></td></tr>
<tr class="separator:a3f601dc216b1e0e8a09927fc156c94eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1fb2dad6903effcf20f65a918dc82a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#abe1fb2dad6903effcf20f65a918dc82a">getRes</a> () const</td></tr>
<tr class="memdesc:abe1fb2dad6903effcf20f65a918dc82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the resolution of the map in [meter/voxel].  <br /></td></tr>
<tr class="separator:abe1fb2dad6903effcf20f65a918dc82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abc51fd056c13597c65aa312a7e345c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ad9f55bfb211664276b34c0f18463a87e">DataConfigType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a1abc51fd056c13597c65aa312a7e345c">getDataConfig</a> () const</td></tr>
<tr class="memdesc:a1abc51fd056c13597c65aa312a7e345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data configuration of the map.  <br /></td></tr>
<tr class="separator:a1abc51fd056c13597c65aa312a7e345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9fe90c14b8cfec9f99cdb1b19f87c4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off&gt; </td></tr>
<tr class="memitem:a0c9fe90c14b8cfec9f99cdb1b19f87c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a0c9fe90c14b8cfec9f99cdb1b19f87c4">getData</a> (const Eigen::Vector3f &amp;point_W) const</td></tr>
<tr class="memdesc:a0c9fe90c14b8cfec9f99cdb1b19f87c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored data at the provided coordinates in [meter].  <br /></td></tr>
<tr class="separator:a0c9fe90c14b8cfec9f99cdb1b19f87c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a01216bd7efc95bc33d1784f18a775"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT&gt; </td></tr>
<tr class="memitem:ab8a01216bd7efc95bc33d1784f18a775"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ab8a01216bd7efc95bc33d1784f18a775">getMinData</a> (const Eigen::Vector3f &amp;point_W, const int scale_desired) const</td></tr>
<tr class="memdesc:ab8a01216bd7efc95bc33d1784f18a775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored min data at the provided coordinates in [meter] for a given scale.  <br /></td></tr>
<tr class="separator:ab8a01216bd7efc95bc33d1784f18a775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c9171f406a735c796936e4befe2338"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT&gt; </td></tr>
<tr class="memitem:a96c9171f406a735c796936e4befe2338"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a96c9171f406a735c796936e4befe2338">getMaxData</a> (const Eigen::Vector3f &amp;point_W, const int scale_desired) const</td></tr>
<tr class="memdesc:a96c9171f406a735c796936e4befe2338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored max data at the provided coordinates in [meter] for a given scale.  <br /></td></tr>
<tr class="separator:a96c9171f406a735c796936e4befe2338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b0e38181398843fbeb09c82d5cc4cc"><td class="memTemplParams" colspan="2">template&lt;typename ValidF , typename GetF , <a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT&gt; </td></tr>
<tr class="memitem:a36b0e38181398843fbeb09c82d5cc4cc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; std::invoke_result_t&lt; GetF, <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a36b0e38181398843fbeb09c82d5cc4cc">getInterp</a> (const Eigen::Vector3f &amp;point_W, ValidF valid, GetF get, int &amp;returned_scale) const</td></tr>
<tr class="memdesc:a36b0e38181398843fbeb09c82d5cc4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a member of <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> at the supplied coordinates and the finest possible scale.  <br /></td></tr>
<tr class="separator:a36b0e38181398843fbeb09c82d5cc4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c0f80e2cc4d3ae66a96a5322a85d61"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, typename ValidF , typename GetF &gt; </td></tr>
<tr class="memitem:a94c0f80e2cc4d3ae66a96a5322a85d61"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::invoke_result_t&lt; GetF, <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a94c0f80e2cc4d3ae66a96a5322a85d61">getInterp</a> (const Eigen::Vector3f &amp;point_W, ValidF valid, GetF get) const</td></tr>
<tr class="memdesc:a94c0f80e2cc4d3ae66a96a5322a85d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a94c0f80e2cc4d3ae66a96a5322a85d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbb6ee33f454d150d37ebf182d1acf9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off&gt; </td></tr>
<tr class="memitem:adcbb6ee33f454d150d37ebf182d1acf9"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">se::field_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#adcbb6ee33f454d150d37ebf182d1acf9">getFieldInterp</a> (const Eigen::Vector3f &amp;point_W) const</td></tr>
<tr class="memdesc:adcbb6ee33f454d150d37ebf182d1acf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interpolated field value at the provided coordinates.  <br /></td></tr>
<tr class="separator:adcbb6ee33f454d150d37ebf182d1acf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193a6175f8f8ee2f86a6f9c37ef08278"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT&gt; </td></tr>
<tr class="memitem:a193a6175f8f8ee2f86a6f9c37ef08278"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">se::field_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a193a6175f8f8ee2f86a6f9c37ef08278">getFieldInterp</a> (const Eigen::Vector3f &amp;point_W, int &amp;returned_scale) const</td></tr>
<tr class="memdesc:a193a6175f8f8ee2f86a6f9c37ef08278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interpolated field value at the provided coordinates and the scale it is stored at.  <br /></td></tr>
<tr class="separator:a193a6175f8f8ee2f86a6f9c37ef08278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c839aff7aa284fdb54931ce58993c65"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColourTDummy = ColB&gt; </td></tr>
<tr class="memitem:a6c839aff7aa284fdb54931ce58993c65"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a> &amp;&amp;ColourTDummy==<a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011a521c36a31c2762741cf0f8890cbe05e3">Colour::On</a>, std::optional&lt; <a class="el" href="namespacese.html#a3773d59e592d829621175de16f791821">colour_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a6c839aff7aa284fdb54931ce58993c65">getColourInterp</a> (const Eigen::Vector3f &amp;point_W, int &amp;returned_scale) const</td></tr>
<tr class="memdesc:a6c839aff7aa284fdb54931ce58993c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the colour at the supplied coordinates and the finest possible scale.  <br /></td></tr>
<tr class="separator:a6c839aff7aa284fdb54931ce58993c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaccb4af0c78083ecfeed5d0f6ac2c8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColourTDummy = ColB&gt; </td></tr>
<tr class="memitem:adaccb4af0c78083ecfeed5d0f6ac2c8f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ColourTDummy==<a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011a521c36a31c2762741cf0f8890cbe05e3">Colour::On</a>, std::optional&lt; <a class="el" href="namespacese.html#a3773d59e592d829621175de16f791821">colour_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#adaccb4af0c78083ecfeed5d0f6ac2c8f">getColourInterp</a> (const Eigen::Vector3f &amp;point_W) const</td></tr>
<tr class="memdesc:adaccb4af0c78083ecfeed5d0f6ac2c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:adaccb4af0c78083ecfeed5d0f6ac2c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fce88b344f41b9c885c9db1b3d2f706"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off&gt; </td></tr>
<tr class="memitem:a1fce88b344f41b9c885c9db1b3d2f706"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacese.html#a0ae75653f6cec9dd7b73580a4ddba6f9">se::field_vec_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a1fce88b344f41b9c885c9db1b3d2f706">getFieldGrad</a> (const Eigen::Vector3f &amp;point_W) const</td></tr>
<tr class="memdesc:a1fce88b344f41b9c885c9db1b3d2f706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the field gradient at the provided coordinates.  <br /></td></tr>
<tr class="separator:a1fce88b344f41b9c885c9db1b3d2f706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87455664327efe803217e91dea1052df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a87455664327efe803217e91dea1052df">saveFieldSlices</a> (const std::string &amp;filename_x, const std::string &amp;filename_y, const std::string &amp;filename_z, const Eigen::Vector3f &amp;point_W) const</td></tr>
<tr class="memdesc:a87455664327efe803217e91dea1052df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save three slices of the field value, each perpendicular to one of the axes (x, y and z) at the provided coordinates.  <br /></td></tr>
<tr class="separator:a87455664327efe803217e91dea1052df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace92c4e48b1654740e6f0141958d4254"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">se::Field</a> FldTDummy = FldT&gt; </td></tr>
<tr class="memitem:ace92c4e48b1654740e6f0141958d4254"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; FldTDummy==<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6ba9b4b1d446cebefa9cf1d6c6d7ef17d70">se::Field::Occupancy</a>, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ace92c4e48b1654740e6f0141958d4254">saveMinFieldSlices</a> (const std::string &amp;filename_x, const std::string &amp;filename_y, const std::string &amp;filename_z, const Eigen::Vector3f &amp;point_W, const int scale) const</td></tr>
<tr class="memdesc:ace92c4e48b1654740e6f0141958d4254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save three slices of the minimum field value, each perpendicular to one of the axes (x, y and z) at the provided coordinates.  <br /></td></tr>
<tr class="separator:ace92c4e48b1654740e6f0141958d4254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89bb9f30d312618f1f484d290aafb20"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">se::Field</a> FldTDummy = FldT&gt; </td></tr>
<tr class="memitem:ad89bb9f30d312618f1f484d290aafb20"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; FldTDummy==<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6ba9b4b1d446cebefa9cf1d6c6d7ef17d70">se::Field::Occupancy</a>, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ad89bb9f30d312618f1f484d290aafb20">saveMaxFieldSlices</a> (const std::string &amp;filename_x, const std::string &amp;filename_y, const std::string &amp;filename_z, const Eigen::Vector3f &amp;point_W, const int scale) const</td></tr>
<tr class="memdesc:ad89bb9f30d312618f1f484d290aafb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save three slices of the maximum field value, each perpendicular to one of the axes (x, y and z) at the provided coordinates.  <br /></td></tr>
<tr class="separator:ad89bb9f30d312618f1f484d290aafb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d3b95ff762c6ddd768c8818cdcb533"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT&gt; </td></tr>
<tr class="memitem:a37d3b95ff762c6ddd768c8818cdcb533"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a37d3b95ff762c6ddd768c8818cdcb533">saveScaleSlices</a> (const std::string &amp;filename_x, const std::string &amp;filename_y, const std::string &amp;filename_z, const Eigen::Vector3f &amp;point_W) const</td></tr>
<tr class="memdesc:a37d3b95ff762c6ddd768c8818cdcb533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save three slices of the integration scale, each perpendicular to one of the axes (x, y and z) at the provided coordinates.  <br /></td></tr>
<tr class="separator:a37d3b95ff762c6ddd768c8818cdcb533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f1d0f76880c66022f5eea13a43dab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aac0c3fe0efa991c1a62521aa29a88369">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a20f1d0f76880c66022f5eea13a43dab9">mesh</a> (const Eigen::Affine3f &amp;T_OW=Eigen::Affine3f::Identity(), const int min_desired_scale=0) const</td></tr>
<tr class="memdesc:a20f1d0f76880c66022f5eea13a43dab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mesh of the reconstructed surface in the world frame in units of metres.  <br /></td></tr>
<tr class="separator:a20f1d0f76880c66022f5eea13a43dab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd0fc57f98835416bc936e5baaa992c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a2fd0fc57f98835416bc936e5baaa992c">saveMesh</a> (const std::string &amp;filename, const Eigen::Affine3f &amp;T_OW=Eigen::Affine3f::Identity(), const int min_desired_scale=0) const</td></tr>
<tr class="memdesc:a2fd0fc57f98835416bc936e5baaa992c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the mesh returned by se::Map::mesh() in <code>filename</code>.  <br /></td></tr>
<tr class="separator:a2fd0fc57f98835416bc936e5baaa992c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291f57a5b1988e7ca5e1707f934ea940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#af6bfa1efd611864f3140bbbd3173b512">StructureMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a291f57a5b1988e7ca5e1707f934ea940">structure</a> (const Eigen::Affine3f &amp;T_OW=Eigen::Affine3f::Identity(), const bool only_leaves=true) const</td></tr>
<tr class="memdesc:a291f57a5b1988e7ca5e1707f934ea940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mesh of the octree structure in the world frame in units of metres.  <br /></td></tr>
<tr class="separator:a291f57a5b1988e7ca5e1707f934ea940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375e3c9fa0ef746a13745313d67c7d2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a375e3c9fa0ef746a13745313d67c7d2d">saveStructure</a> (const std::string &amp;filename, const Eigen::Affine3f &amp;T_OW=Eigen::Affine3f::Identity(), const bool only_leaves=true) const</td></tr>
<tr class="memdesc:a375e3c9fa0ef746a13745313d67c7d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the mesh returned by se::Map::structure_meshing() in <code>filename</code>.  <br /></td></tr>
<tr class="separator:a375e3c9fa0ef746a13745313d67c7d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d26ecbf791b4a2eb1e1f5893c841da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ad2d26ecbf791b4a2eb1e1f5893c841da">voxelToPoint</a> (const Eigen::Vector3i &amp;voxel_coord, Eigen::Vector3f &amp;point_W) const</td></tr>
<tr class="memdesc:ad2d26ecbf791b4a2eb1e1f5893c841da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert voxel coordinates in [voxel] to its centre point coordinates in [meter].  <br /></td></tr>
<tr class="separator:ad2d26ecbf791b4a2eb1e1f5893c841da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f3f035dea19e9e124d932b434a26b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a53f3f035dea19e9e124d932b434a26b1">voxelToPoint</a> (const Eigen::Vector3i &amp;voxel_coord, const int voxel_size, Eigen::Vector3f &amp;point_W) const</td></tr>
<tr class="memdesc:a53f3f035dea19e9e124d932b434a26b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert voxel coordinates in [voxel] for a given voxel size to its centre point coordinates in [meter].  <br /></td></tr>
<tr class="separator:a53f3f035dea19e9e124d932b434a26b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c902f50065f0d08ddf4d4c9523e5d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a86c902f50065f0d08ddf4d4c9523e5d5">voxelToCornerPoints</a> (const Eigen::Vector3i &amp;voxel_coord, Eigen::Matrix&lt; float, 3, 8 &gt; &amp;corner_points_W) const</td></tr>
<tr class="memdesc:a86c902f50065f0d08ddf4d4c9523e5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert voxel coordinates in [voxel] for a given voxel size to its eight corner point coordinates in [meter].  <br /></td></tr>
<tr class="separator:a86c902f50065f0d08ddf4d4c9523e5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64754e15903b5c1bbbef72a7d2c1fd65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a64754e15903b5c1bbbef72a7d2c1fd65">voxelToCornerPoints</a> (const Eigen::Vector3i &amp;voxel_coord, const int voxel_size, Eigen::Matrix&lt; float, 3, 8 &gt; &amp;corner_points_W) const</td></tr>
<tr class="memdesc:a64754e15903b5c1bbbef72a7d2c1fd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert voxel coordinates in [voxel] for a given voxel size to its eight corner point coordinates in [meter].  <br /></td></tr>
<tr class="separator:a64754e15903b5c1bbbef72a7d2c1fd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec93f094578823acdfb68c42d842e45c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB = se::Safe::On&gt; </td></tr>
<tr class="memitem:aec93f094578823acdfb68c42d842e45c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246a521c36a31c2762741cf0f8890cbe05e3">se::Safe::On</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aec93f094578823acdfb68c42d842e45c">pointToVoxel</a> (const Eigen::Vector3f &amp;point_W, Eigen::Vector3i &amp;voxel_coord) const</td></tr>
<tr class="memdesc:aec93f094578823acdfb68c42d842e45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert point coordinates in [meter] to its voxel coordinates (bottom, front, left corner) in [voxel].  <br /></td></tr>
<tr class="separator:aec93f094578823acdfb68c42d842e45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9dc6c3a2b9e9f6878ff6a8c036efdf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </td></tr>
<tr class="memitem:afb9dc6c3a2b9e9f6878ff6a8c036efdf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246ad15305d7a4e34e02489c74a5ef542f36">se::Safe::Off</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#afb9dc6c3a2b9e9f6878ff6a8c036efdf">pointToVoxel</a> (const Eigen::Vector3f &amp;point_W, Eigen::Vector3i &amp;voxel_coord) const</td></tr>
<tr class="memdesc:afb9dc6c3a2b9e9f6878ff6a8c036efdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert point coordinates in [meter] to its voxel coordinates (bottom, front, left corner) in [voxel].  <br /></td></tr>
<tr class="separator:afb9dc6c3a2b9e9f6878ff6a8c036efdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada2fd9ba3dfa8066e86861c898f4907"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB = se::Safe::On&gt; </td></tr>
<tr class="memitem:aada2fd9ba3dfa8066e86861c898f4907"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246a521c36a31c2762741cf0f8890cbe05e3">se::Safe::On</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aada2fd9ba3dfa8066e86861c898f4907">pointToVoxel</a> (const Eigen::Vector3f &amp;point_W, Eigen::Vector3f &amp;voxel_coord_f) const</td></tr>
<tr class="memdesc:aada2fd9ba3dfa8066e86861c898f4907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert point coordinates in [meter] to its voxel coordinates in [voxel].  <br /></td></tr>
<tr class="separator:aada2fd9ba3dfa8066e86861c898f4907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf996b09840b15a247209f9721ddddf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </td></tr>
<tr class="memitem:abcf996b09840b15a247209f9721ddddf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246ad15305d7a4e34e02489c74a5ef542f36">se::Safe::Off</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#abcf996b09840b15a247209f9721ddddf">pointToVoxel</a> (const Eigen::Vector3f &amp;point_W, Eigen::Vector3f &amp;voxel_coord_f) const</td></tr>
<tr class="memdesc:abcf996b09840b15a247209f9721ddddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert point coordinates in [meter] to its voxel coordinates in [voxel].  <br /></td></tr>
<tr class="separator:abcf996b09840b15a247209f9721ddddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c81cb918f28b7499b3374686fccd94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB = se::Safe::On&gt; </td></tr>
<tr class="memitem:ab9c81cb918f28b7499b3374686fccd94"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246a521c36a31c2762741cf0f8890cbe05e3">se::Safe::On</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ab9c81cb918f28b7499b3374686fccd94">pointsToVoxels</a> (const std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;points_W, std::vector&lt; Eigen::Vector3i, Eigen::aligned_allocator&lt; Eigen::Vector3i &gt; &gt; &amp;voxel_coords) const</td></tr>
<tr class="memdesc:ab9c81cb918f28b7499b3374686fccd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of point coordinates in [meter] to its voxel coordinates in [voxel].  <br /></td></tr>
<tr class="separator:ab9c81cb918f28b7499b3374686fccd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddb45656cfb13346a94263455178906"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </td></tr>
<tr class="memitem:afddb45656cfb13346a94263455178906"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246ad15305d7a4e34e02489c74a5ef542f36">se::Safe::Off</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#afddb45656cfb13346a94263455178906">pointsToVoxels</a> (const std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;points_W, std::vector&lt; Eigen::Vector3i, Eigen::aligned_allocator&lt; Eigen::Vector3i &gt; &gt; &amp;voxel_coords) const</td></tr>
<tr class="memdesc:afddb45656cfb13346a94263455178906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of point coordinates in [meter] to its voxel coordinates in [voxel].  <br /></td></tr>
<tr class="separator:afddb45656cfb13346a94263455178906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470dac01b6a75e9b12813e43d42f3df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aa8ce519441156a1fb5f47857ed8a7580">OctreeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a470dac01b6a75e9b12813e43d42f3df8">getOctree</a> ()</td></tr>
<tr class="memdesc:a470dac01b6a75e9b12813e43d42f3df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the internal <a class="el" href="classse_1_1Octree.html" title="The octree data structure containing the map data.">se::Octree</a>.  <br /></td></tr>
<tr class="separator:a470dac01b6a75e9b12813e43d42f3df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c3a20df109fc499e7ba067e3d850d7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aa8ce519441156a1fb5f47857ed8a7580">OctreeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a62c3a20df109fc499e7ba067e3d850d7">getOctree</a> () const</td></tr>
<tr class="memdesc:a62c3a20df109fc499e7ba067e3d850d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a constant reference to the internal <a class="el" href="classse_1_1Octree.html" title="The octree data structure containing the map data.">se::Octree</a>.  <br /></td></tr>
<tr class="separator:a62c3a20df109fc499e7ba067e3d850d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823bd0479d58ba2c47b8a30552604d4d"><td class="memItemLeft" align="right" valign="top">const Eigen::AlignedBox3f &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a823bd0479d58ba2c47b8a30552604d4d">aabb</a> () const</td></tr>
<tr class="memdesc:a823bd0479d58ba2c47b8a30552604d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the axis-aligned bounding box in the world frame W of the map's allocated leaves.  <br /></td></tr>
<tr class="separator:a823bd0479d58ba2c47b8a30552604d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0b7daa37882810cbf5226a129afadf30"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a0b7daa37882810cbf5226a129afadf30">fld_</a> = FldT</td></tr>
<tr class="separator:a0b7daa37882810cbf5226a129afadf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc7eb4c7e1b03ddfd1d541db001df7c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a0cc7eb4c7e1b03ddfd1d541db001df7c">col_</a> = ColB</td></tr>
<tr class="separator:a0cc7eb4c7e1b03ddfd1d541db001df7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aca98cdf2f8f6fc3958ee3266e9441"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ab3aca98cdf2f8f6fc3958ee3266e9441">sem_</a> = SemB</td></tr>
<tr class="separator:ab3aca98cdf2f8f6fc3958ee3266e9441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79201beba1d1f55cbbb9cb7757b73cdb"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a79201beba1d1f55cbbb9cb7757b73cdb">res_</a> = ResT</td></tr>
<tr class="separator:a79201beba1d1f55cbbb9cb7757b73cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a41bd613d17f671ffa518149337075a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aa8ce519441156a1fb5f47857ed8a7580">OctreeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a41bd613d17f671ffa518149337075a49">octree_</a></td></tr>
<tr class="separator:a41bd613d17f671ffa518149337075a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567d18a63db64237bb3dd874d53beaf6"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a567d18a63db64237bb3dd874d53beaf6">resolution_</a></td></tr>
<tr class="memdesc:a567d18a63db64237bb3dd874d53beaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resolution of the map.  <br /></td></tr>
<tr class="separator:a567d18a63db64237bb3dd874d53beaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b67bbd5e2cbd5a9ac6d17a18961a2b"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a05b67bbd5e2cbd5a9ac6d17a18961a2b">dimension_</a></td></tr>
<tr class="memdesc:a05b67bbd5e2cbd5a9ac6d17a18961a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensions of the map.  <br /></td></tr>
<tr class="separator:a05b67bbd5e2cbd5a9ac6d17a18961a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de66378323332d3ae9da3b12d176fcf"><td class="memItemLeft" align="right" valign="top">const Eigen::Isometry3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a0de66378323332d3ae9da3b12d176fcf">T_MW_</a></td></tr>
<tr class="memdesc:a0de66378323332d3ae9da3b12d176fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transformation from world to map frame.  <br /></td></tr>
<tr class="separator:a0de66378323332d3ae9da3b12d176fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea100644f9aa9b350b7c56937b379c5"><td class="memItemLeft" align="right" valign="top">const Eigen::Isometry3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a2ea100644f9aa9b350b7c56937b379c5">T_WM_</a></td></tr>
<tr class="memdesc:a2ea100644f9aa9b350b7c56937b379c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transformation from map to world frame.  <br /></td></tr>
<tr class="separator:a2ea100644f9aa9b350b7c56937b379c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7763c604afabd89e02d8e7cb7ec5b9f4"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a7763c604afabd89e02d8e7cb7ec5b9f4">lb_M_</a></td></tr>
<tr class="memdesc:a7763c604afabd89e02d8e7cb7ec5b9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lower map bound.  <br /></td></tr>
<tr class="separator:a7763c604afabd89e02d8e7cb7ec5b9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1293febda1829a0c2d3c868e8710d4"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a1b1293febda1829a0c2d3c868e8710d4">ub_M_</a></td></tr>
<tr class="memdesc:a1b1293febda1829a0c2d3c868e8710d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The upper map bound.  <br /></td></tr>
<tr class="separator:a1b1293febda1829a0c2d3c868e8710d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8866b5d1dbffc05a9c8bdeb0cf51363f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ad9f55bfb211664276b34c0f18463a87e">DataConfigType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a8866b5d1dbffc05a9c8bdeb0cf51363f">data_config_</a></td></tr>
<tr class="memdesc:a8866b5d1dbffc05a9c8bdeb0cf51363f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration of the data.  <br /></td></tr>
<tr class="separator:a8866b5d1dbffc05a9c8bdeb0cf51363f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59099b137b26db22833c0c09029c945"><td class="memItemLeft" align="right" valign="top">Eigen::AlignedBox3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aa59099b137b26db22833c0c09029c945">cached_aabb_</a></td></tr>
<tr class="separator:aa59099b137b26db22833c0c09029c945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daef84523801bfbf838ba1266db418a"><td class="memItemLeft" align="right" valign="top">Eigen::AlignedBox3i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a9daef84523801bfbf838ba1266db418a">cached_octree_aabb_</a></td></tr>
<tr class="separator:a9daef84523801bfbf838ba1266db418a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a6d1a8494a68035e4aab8fa6a9831c35d"><td class="memItemLeft" align="right" valign="top">static const Eigen::Matrix&lt; float, 3, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#a6d1a8494a68035e4aab8fa6a9831c35d">corner_rel_steps_</a></td></tr>
<tr class="memdesc:a6d1a8494a68035e4aab8fa6a9831c35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The eight relative unit corner offsets.  <br /></td></tr>
<tr class="separator:a6d1a8494a68035e4aab8fa6a9831c35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaf6ffffacbdcfc1d8e9dd09d67c66e0f" name="aaf6ffffacbdcfc1d8e9dd09d67c66e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">&#9670;&#160;</a></span>DataType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structse_1_1Data.html">Data</a>&lt;FldT, ColB, SemB&gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::DataType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9f55bfb211664276b34c0f18463a87e" name="ad9f55bfb211664276b34c0f18463a87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f55bfb211664276b34c0f18463a87e">&#9670;&#160;</a></span>DataConfigType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structse_1_1Data.html">Data</a>&lt;FldT,ColB,SemB&gt;::Config <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::DataConfigType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8ce519441156a1fb5f47857ed8a7580" name="aa8ce519441156a1fb5f47857ed8a7580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ce519441156a1fb5f47857ed8a7580">&#9670;&#160;</a></span>OctreeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classse_1_1Octree.html">se::Octree</a>&lt;<a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a>, ResT, BlockSize&gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::OctreeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac0c3fe0efa991c1a62521aa29a88369" name="aac0c3fe0efa991c1a62521aa29a88369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0c3fe0efa991c1a62521aa29a88369">&#9670;&#160;</a></span>SurfaceMesh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classse_1_1Octree.html#adb95da91a3361a8c9f18ab52d6d9148d">OctreeType::SurfaceMesh</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::SurfaceMesh</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6bfa1efd611864f3140bbbd3173b512" name="af6bfa1efd611864f3140bbbd3173b512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bfa1efd611864f3140bbbd3173b512">&#9670;&#160;</a></span>StructureMesh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classse_1_1Octree.html#a7d20cc0d44e20c4f9b098d168e5a87b2">OctreeType::StructureMesh</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::StructureMesh</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac47ed9cb24673e5e9262eed247e61295" name="ac47ed9cb24673e5e9262eed247e61295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47ed9cb24673e5e9262eed247e61295">&#9670;&#160;</a></span>Map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::Map </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structse_1_1Data.html">Data</a>&lt; FldT, ColB, SemB &gt;::Config &amp;&#160;</td>
          <td class="paramname"><em>data_config</em> = <code>typename&#160;<a class="el" href="structse_1_1Data.html">Data</a>&lt;&#160;FldT,&#160;ColB,&#160;SemB&#160;&gt;::Config()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The map constructor. </p>
<dl class="section note"><dt>Note</dt><dd>Default map origin is set at the centre of the map.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The dimension of the map in [meter] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>The resolution of the map in [meter/voxel] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_config</td><td>The configuration file for the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e5ee3b594d3de916a25d76d6f055774" name="a4e5ee3b594d3de916a25d76d6f055774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5ee3b594d3de916a25d76d6f055774">&#9670;&#160;</a></span>Map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::Map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structse_1_1Config.html">Config</a> &amp;&#160;</td>
          <td class="paramname"><em>map_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structse_1_1Data.html">Data</a>&lt; FldT, ColB, SemB &gt;::Config &amp;&#160;</td>
          <td class="paramname"><em>data_config</em> = <code>typename&#160;<a class="el" href="structse_1_1Data.html">Data</a>&lt;&#160;FldT,&#160;ColB,&#160;SemB&#160;&gt;::Config()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The map constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map_config</td><td>The configuration file for the map (e.g. map dimension, resolution and origin) </td></tr>
    <tr><td class="paramname">data_config</td><td>The configuration file for the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55d574f583c45cf408da6250056b064e" name="a55d574f583c45cf408da6250056b064e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d574f583c45cf408da6250056b064e">&#9670;&#160;</a></span>Map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::Map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classse_1_1Map.html">Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor is explicitly deleted. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4233091867e74ac27cd8de487653a605" name="a4233091867e74ac27cd8de487653a605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4233091867e74ac27cd8de487653a605">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Map.html">Map</a> &amp; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classse_1_1Map.html">Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy assignment operator is explicitly deleted. </p>

</div>
</div>
<a id="a1bfb0229678799eea0eb87d5d9f82024" name="a1bfb0229678799eea0eb87d5d9f82024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfb0229678799eea0eb87d5d9f82024">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if a point is inside the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The point to be verified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point is inside the map, false otherwise </dd></dl>

</div>
</div>
<a id="a9e771a71c068d985017b8c6398952c7e" name="a9e771a71c068d985017b8c6398952c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e771a71c068d985017b8c6398952c7e">&#9670;&#160;</a></span>getTMW()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Isometry3f &amp; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getTMW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the transformation from world to map frame. </p>
<dl class="section return"><dt>Returns</dt><dd>T_MW </dd></dl>

</div>
</div>
<a id="af46301ef15afe4d0c6822f9ae1a3830a" name="af46301ef15afe4d0c6822f9ae1a3830a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46301ef15afe4d0c6822f9ae1a3830a">&#9670;&#160;</a></span>getTWM()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Isometry3f &amp; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getTWM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the transformation from map to world frame. </p>
<dl class="section return"><dt>Returns</dt><dd>T_WM </dd></dl>

</div>
</div>
<a id="a3f601dc216b1e0e8a09927fc156c94eb" name="a3f601dc216b1e0e8a09927fc156c94eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f601dc216b1e0e8a09927fc156c94eb">&#9670;&#160;</a></span>getDim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3f &amp; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimensions of the map in [meter] (length x width x height) </p>
<dl class="section return"><dt>Returns</dt><dd>The dimensions of the map </dd></dl>

</div>
</div>
<a id="abe1fb2dad6903effcf20f65a918dc82a" name="abe1fb2dad6903effcf20f65a918dc82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1fb2dad6903effcf20f65a918dc82a">&#9670;&#160;</a></span>getRes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getRes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the resolution of the map in [meter/voxel]. </p>
<dl class="section return"><dt>Returns</dt><dd>The resolution of the map </dd></dl>

</div>
</div>
<a id="a1abc51fd056c13597c65aa312a7e345c" name="a1abc51fd056c13597c65aa312a7e345c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abc51fd056c13597c65aa312a7e345c">&#9670;&#160;</a></span>getDataConfig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ad9f55bfb211664276b34c0f18463a87e">DataConfigType</a> &amp; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getDataConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data configuration of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>The data configuration of the map </dd></dl>

</div>
</div>
<a id="a0c9fe90c14b8cfec9f99cdb1b19f87c4" name="a0c9fe90c14b8cfec9f99cdb1b19f87c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9fe90c14b8cfec9f99cdb1b19f87c4">&#9670;&#160;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getData </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the stored data at the provided coordinates in [meter]. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (Off by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The coordinates of the point in world frame [meter] to evaluate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data at the provided coordinates </dd></dl>

</div>
</div>
<a id="ab8a01216bd7efc95bc33d1784f18a775" name="ab8a01216bd7efc95bc33d1784f18a775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a01216bd7efc95bc33d1784f18a775">&#9670;&#160;</a></span>getMinData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getMinData </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale_desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the stored min data at the provided coordinates in [meter] for a given scale. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (Off by default) </td></tr>
    <tr><td class="paramname">ResTDummy</td><td>The dummy parameter disabling the function off for single res and TSDF maps // TODO: Clean up with C++20 using required </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_W</td><td>The coordinates of the point in world frame [meter] to accessed </td></tr>
    <tr><td class="paramname">scale_desired</td><td>The scale to be accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The min data at the provided coordinates and scale </dd></dl>

</div>
</div>
<a id="a96c9171f406a735c796936e4befe2338" name="a96c9171f406a735c796936e4befe2338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c9171f406a735c796936e4befe2338">&#9670;&#160;</a></span>getMaxData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getMaxData </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale_desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stored max data at the provided coordinates in [meter] for a given scale. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (Off by default) </td></tr>
    <tr><td class="paramname">ResTDummy</td><td>The dummy parameter disabling the function off for single res and TSDF maps // TODO: Clean up with C++20 using required </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_W</td><td>The coordinates of the point in world frame [meter] to accessed </td></tr>
    <tr><td class="paramname">scale_desired</td><td>The scale to be accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The max data at the provided coordinates and scale </dd></dl>

</div>
</div>
<a id="a36b0e38181398843fbeb09c82d5cc4cc" name="a36b0e38181398843fbeb09c82d5cc4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b0e38181398843fbeb09c82d5cc4cc">&#9670;&#160;</a></span>getInterp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;typename ValidF , typename GetF , <a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; std::invoke_result_t&lt; GetF, <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> &gt; &gt; &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getInterp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidF&#160;</td>
          <td class="paramname"><em>valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetF&#160;</td>
          <td class="paramname"><em>get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>returned_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a member of <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> at the supplied coordinates and the finest possible scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The coordinates in metres of the point in the world frame W the member will be interpolated at. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid</td><td>A functor with the following prototype, returning whether the supplied data is valid and should be used for interpolation: <div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OctreeT&gt;</div>
<div class="line"><span class="keywordtype">bool</span> valid(<span class="keyword">const</span> <span class="keyword">typename</span> OctreeT::DataType&amp; data);</div>
</div><!-- fragment --> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get</td><td>A functor with the following prototype, returning the member of type <code>T</code> to be interpolated: <div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OctreeT&gt;</div>
<div class="line">T get(<span class="keyword">const</span> <span class="keyword">typename</span> OctreeT::DataType&amp; data);</div>
</div><!-- fragment --> Type <code>T</code> must implement the following operators: <div class="fragment"><div class="line">T operator+(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b);</div>
<div class="line">T operator*(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span> b);</div>
</div><!-- fragment --> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">returned_scale</td><td>The scale the member was interpolated at. Not modified if <code>std::nullopt</code> is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated member if the data is valid, <code>std::nullopt</code> otherwise. </dd></dl>

</div>
</div>
<a id="a94c0f80e2cc4d3ae66a96a5322a85d61" name="a94c0f80e2cc4d3ae66a96a5322a85d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c0f80e2cc4d3ae66a96a5322a85d61">&#9670;&#160;</a></span>getInterp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, typename ValidF , typename GetF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::invoke_result_t&lt; GetF, <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aaf6ffffacbdcfc1d8e9dd09d67c66e0f">DataType</a> &gt; &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getInterp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidF&#160;</td>
          <td class="paramname"><em>valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetF&#160;</td>
          <td class="paramname"><em>get</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>This overload works for both single- and multi-resolution maps. In the case of a multi-resolution map the member is interpolated at the finest possible scale. </p>

</div>
</div>
<a id="adcbb6ee33f454d150d37ebf182d1acf9" name="adcbb6ee33f454d150d37ebf182d1acf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbb6ee33f454d150d37ebf182d1acf9">&#9670;&#160;</a></span>getFieldInterp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">se::field_t</a> &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getFieldInterp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the interpolated field value at the provided coordinates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (Off by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The coordinates of the point in world frame [meter] to accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated field value at the coordinates </dd></dl>

</div>
</div>
<a id="a193a6175f8f8ee2f86a6f9c37ef08278" name="a193a6175f8f8ee2f86a6f9c37ef08278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193a6175f8f8ee2f86a6f9c37ef08278">&#9670;&#160;</a></span>getFieldInterp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">se::field_t</a> &gt; &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getFieldInterp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>returned_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the interpolated field value at the provided coordinates and the scale it is stored at. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (Off by default) </td></tr>
    <tr><td class="paramname">ResTDummy</td><td>The dummy parameter disabling the function off for single res maps // TODO: Clean up with C++20 using required </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The coordinates of the point in world frame [meter] to accessed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">returned_scale</td><td>The scale the data is stored at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated field value at the coordinates </dd></dl>

</div>
</div>
<a id="a6c839aff7aa284fdb54931ce58993c65" name="a6c839aff7aa284fdb54931ce58993c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c839aff7aa284fdb54931ce58993c65">&#9670;&#160;</a></span>getColourInterp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColourTDummy = ColB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a> &amp;&amp;ColourTDummy==<a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011a521c36a31c2762741cf0f8890cbe05e3">Colour::On</a>, std::optional&lt; <a class="el" href="namespacese.html#a3773d59e592d829621175de16f791821">colour_t</a> &gt; &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getColourInterp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>returned_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate the colour at the supplied coordinates and the finest possible scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The coordinates in metres of the point in the world frame W the colour will be interpolated at. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">returned_scale</td><td>The scale the colour was interpolated at. Not modified if <code>std::nullopt</code> is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated colour if the data is valid, <code>std::nullopt</code> otherwise. </dd></dl>

</div>
</div>
<a id="adaccb4af0c78083ecfeed5d0f6ac2c8f" name="adaccb4af0c78083ecfeed5d0f6ac2c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaccb4af0c78083ecfeed5d0f6ac2c8f">&#9670;&#160;</a></span>getColourInterp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColourTDummy = ColB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ColourTDummy==<a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011a521c36a31c2762741cf0f8890cbe05e3">Colour::On</a>, std::optional&lt; <a class="el" href="namespacese.html#a3773d59e592d829621175de16f791821">colour_t</a> &gt; &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getColourInterp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>This overload works for both single- and multi-resolution maps. In the case of a multi-resolution map the colour is interpolated at the finest possible scale. </p>

</div>
</div>
<a id="a1fce88b344f41b9c885c9db1b3d2f706" name="a1fce88b344f41b9c885c9db1b3d2f706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fce88b344f41b9c885c9db1b3d2f706">&#9670;&#160;</a></span>getFieldGrad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">Safe</a> SafeB = Safe::Off&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacese.html#a0ae75653f6cec9dd7b73580a4ddba6f9">se::field_vec_t</a> &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getFieldGrad </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the field gradient at the provided coordinates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (Off by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The coordinates of the point in world frame [meter] to accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The filed gradient at the coordinates </dd></dl>

</div>
</div>
<a id="a87455664327efe803217e91dea1052df" name="a87455664327efe803217e91dea1052df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87455664327efe803217e91dea1052df">&#9670;&#160;</a></span>saveFieldSlices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::saveFieldSlices </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save three slices of the field value, each perpendicular to one of the axes (x, y and z) at the provided coordinates. </p>
<p>Setting any of the filenames to the empty string will skip saving the respective slice.</p>
<dl class="section note"><dt>Note</dt><dd>Only VTK (<code>.vtk</code>) files are currently supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_x</td><td>The file where the slice perpendicular to the x axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_y</td><td>The file where the slice perpendicular to the y axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_z</td><td>The file where the slice perpendicular to the z axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The point in the world frame in units of meters where the slices intersect. The x coordinate denotes the position along the x axis that the slice perpendicular to the x axis will be computed etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success and non-zero on error. </dd></dl>

</div>
</div>
<a id="ace92c4e48b1654740e6f0141958d4254" name="ace92c4e48b1654740e6f0141958d4254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace92c4e48b1654740e6f0141958d4254">&#9670;&#160;</a></span>saveMinFieldSlices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">se::Field</a> FldTDummy = FldT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; FldTDummy==<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6ba9b4b1d446cebefa9cf1d6c6d7ef17d70">se::Field::Occupancy</a>, int &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::saveMinFieldSlices </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save three slices of the minimum field value, each perpendicular to one of the axes (x, y and z) at the provided coordinates. </p>
<p>Setting any of the filenames to the empty string will skip saving the respective slice.</p>
<dl class="section note"><dt>Note</dt><dd>Only VTK (<code>.vtk</code>) files are currently supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_x</td><td>The file where the slice perpendicular to the x axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_y</td><td>The file where the slice perpendicular to the y axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_z</td><td>The file where the slice perpendicular to the z axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The point in the world frame in units of meters where the slices intersect. The x coordinate denotes the position along the x axis that the slice perpendicular to the x axis will be computed etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The minimum scale the minimum field values will be extracted from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success and non-zero on error. </dd></dl>

</div>
</div>
<a id="ad89bb9f30d312618f1f484d290aafb20" name="ad89bb9f30d312618f1f484d290aafb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89bb9f30d312618f1f484d290aafb20">&#9670;&#160;</a></span>saveMaxFieldSlices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">se::Field</a> FldTDummy = FldT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; FldTDummy==<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6ba9b4b1d446cebefa9cf1d6c6d7ef17d70">se::Field::Occupancy</a>, int &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::saveMaxFieldSlices </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save three slices of the maximum field value, each perpendicular to one of the axes (x, y and z) at the provided coordinates. </p>
<p>Setting any of the filenames to the empty string will skip saving the respective slice.</p>
<dl class="section note"><dt>Note</dt><dd>Only VTK (<code>.vtk</code>) files are currently supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_x</td><td>The file where the slice perpendicular to the x axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_y</td><td>The file where the slice perpendicular to the y axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_z</td><td>The file where the slice perpendicular to the z axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The point in the world frame in units of meters where the slices intersect. The x coordinate denotes the position along the x axis that the slice perpendicular to the x axis will be computed etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The minimum scale the maximum field values will be extracted from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success and non-zero on error. </dd></dl>

</div>
</div>
<a id="a37d3b95ff762c6ddd768c8818cdcb533" name="a37d3b95ff762c6ddd768c8818cdcb533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d3b95ff762c6ddd768c8818cdcb533">&#9670;&#160;</a></span>saveScaleSlices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResTDummy = ResT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ResTDummy==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, int &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::saveScaleSlices </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save three slices of the integration scale, each perpendicular to one of the axes (x, y and z) at the provided coordinates. </p>
<p>Setting any of the filenames to the empty string will skip saving the respective slice.</p>
<dl class="section note"><dt>Note</dt><dd>Only VTK (<code>.vtk</code>) files are currently supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_x</td><td>The file where the slice perpendicular to the x axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_y</td><td>The file where the slice perpendicular to the y axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename_z</td><td>The file where the slice perpendicular to the z axis will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The point in the world frame in units of meters where the slices intersect. The x coordinate denotes the position along the x axis that the slice perpendicular to the x axis will be computed etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success and non-zero on error. </dd></dl>

</div>
</div>
<a id="a20f1d0f76880c66022f5eea13a43dab9" name="a20f1d0f76880c66022f5eea13a43dab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f1d0f76880c66022f5eea13a43dab9">&#9670;&#160;</a></span>mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aac0c3fe0efa991c1a62521aa29a88369">SurfaceMesh</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>T_OW</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_desired_scale</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mesh of the reconstructed surface in the world frame in units of metres. </p>
<p>Apply a transformation, from the world frame W to some output frame O, <code>T_OW</code> to each mesh vertex. For <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">se::Res::Multi</a> maps, only data at scale <code>min_desired_scale</code> or coarser will be used to generate the mesh. This allows generating a coarser mesh which is less demanding in terms of computational time and memory. The value of <code>min_desired_scale</code> has no effect on <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">se::Res::Single</a> maps. </p>

</div>
</div>
<a id="a2fd0fc57f98835416bc936e5baaa992c" name="a2fd0fc57f98835416bc936e5baaa992c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd0fc57f98835416bc936e5baaa992c">&#9670;&#160;</a></span>saveMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::saveMesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>T_OW</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_desired_scale</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the mesh returned by se::Map::mesh() in <code>filename</code>. </p>
<p>The <code>T_OW</code> and <code>min_desired_scale</code> arguments are passed directly to se::Map::mesh(). The file format will be selected based on the extension of <code>filename</code>, which must be one of those in <a class="el" href="namespacese_1_1io.html#a2fa055ecd523d1c81f7f90bd36bb0095" title="The supported file extensions for mesh files.">se::io::mesh_extensions</a>. Return the value returned by <a class="el" href="namespacese_1_1io.html#a85fc2a41c10704ff9ab85615cd895b05" title="Save a mesh to a file whose type is determined by the extension of filename.">se::io::save_mesh()</a>. </p>

</div>
</div>
<a id="a291f57a5b1988e7ca5e1707f934ea940" name="a291f57a5b1988e7ca5e1707f934ea940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291f57a5b1988e7ca5e1707f934ea940">&#9670;&#160;</a></span>structure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#af6bfa1efd611864f3140bbbd3173b512">StructureMesh</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::structure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>T_OW</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>only_leaves</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mesh of the octree structure in the world frame in units of metres. </p>
<p>Apply a transformation, from the world frame W to some output frame O, <code>T_OW</code> to each mesh vertex. The <code>only_leaves</code> argument is passed directly to <a class="el" href="namespacese.html#a7e51652bfc20b71a358017db1c9a1610" title="Return a mesh of the octants of octree.">se::octree_structure_mesh()</a>. </p>

</div>
</div>
<a id="a375e3c9fa0ef746a13745313d67c7d2d" name="a375e3c9fa0ef746a13745313d67c7d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375e3c9fa0ef746a13745313d67c7d2d">&#9670;&#160;</a></span>saveStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::saveStructure </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>T_OW</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>only_leaves</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the mesh returned by se::Map::structure_meshing() in <code>filename</code>. </p>
<p>The <code>T_OW</code> and <code>only_leaves</code> arguments are passed directly to se::Map::structure(). The file format will be selected based on the extension of <code>filename</code>, which must be one of those in <a class="el" href="namespacese_1_1io.html#a2fa055ecd523d1c81f7f90bd36bb0095" title="The supported file extensions for mesh files.">se::io::mesh_extensions</a>. Return the value returned by <a class="el" href="namespacese_1_1io.html#a85fc2a41c10704ff9ab85615cd895b05" title="Save a mesh to a file whose type is determined by the extension of filename.">se::io::save_mesh()</a>. </p>

</div>
</div>
<a id="ad2d26ecbf791b4a2eb1e1f5893c841da" name="ad2d26ecbf791b4a2eb1e1f5893c841da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d26ecbf791b4a2eb1e1f5893c841da">&#9670;&#160;</a></span>voxelToPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::voxelToPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert voxel coordinates in [voxel] to its centre point coordinates in [meter]. </p>
<dl class="section warning"><dt>Warning</dt><dd>The function assumes the voxel has size 1 (i.e. scale 0).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates in [voxel] to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">point_W</td><td>The converted centre point coordinates in [meter] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53f3f035dea19e9e124d932b434a26b1" name="a53f3f035dea19e9e124d932b434a26b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f3f035dea19e9e124d932b434a26b1">&#9670;&#160;</a></span>voxelToPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::voxelToPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>voxel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert voxel coordinates in [voxel] for a given voxel size to its centre point coordinates in [meter]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates in [voxel] to be converted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_size</td><td>The size of the voxel in [voxel] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">point_W</td><td>The converted centre point coordinates in [meter] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86c902f50065f0d08ddf4d4c9523e5d5" name="a86c902f50065f0d08ddf4d4c9523e5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c902f50065f0d08ddf4d4c9523e5d5">&#9670;&#160;</a></span>voxelToCornerPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::voxelToCornerPoints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner_points_W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert voxel coordinates in [voxel] for a given voxel size to its eight corner point coordinates in [meter]. </p>
<dl class="section warning"><dt>Warning</dt><dd>The function assumes the voxel has size 1 (i.e. scale 0).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates in [voxel] to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">corner_points_W</td><td>The converted centre point coordinates in [meter] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64754e15903b5c1bbbef72a7d2c1fd65" name="a64754e15903b5c1bbbef72a7d2c1fd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64754e15903b5c1bbbef72a7d2c1fd65">&#9670;&#160;</a></span>voxelToCornerPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::voxelToCornerPoints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>voxel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner_points_W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert voxel coordinates in [voxel] for a given voxel size to its eight corner point coordinates in [meter]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates in [voxel] to be converted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_size</td><td>The size of the voxel in [voxel] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">corner_points_W</td><td>The converted centre point coordinates in [meter] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec93f094578823acdfb68c42d842e45c" name="aec93f094578823acdfb68c42d842e45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec93f094578823acdfb68c42d842e45c">&#9670;&#160;</a></span>pointToVoxel() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB = se::Safe::On&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246a521c36a31c2762741cf0f8890cbe05e3">se::Safe::On</a>, bool &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::pointToVoxel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert point coordinates in [meter] to its voxel coordinates (bottom, front, left corner) in [voxel]. </p>
<dl class="section note"><dt>Note</dt><dd>Use as `map. template pointToVoxel&lt;se::Safe::Off&gt;(...)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (On by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The point coordinates in [meter] to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">voxel_coord</td><td>The converted voxel coordinates (bottom, front, left corner) in [voxel] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point inside the map, false otherwise </dd></dl>

</div>
</div>
<a id="afb9dc6c3a2b9e9f6878ff6a8c036efdf" name="afb9dc6c3a2b9e9f6878ff6a8c036efdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9dc6c3a2b9e9f6878ff6a8c036efdf">&#9670;&#160;</a></span>pointToVoxel() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246ad15305d7a4e34e02489c74a5ef542f36">se::Safe::Off</a>, bool &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::pointToVoxel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert point coordinates in [meter] to its voxel coordinates (bottom, front, left corner) in [voxel]. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (On by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The point coordinates in [meter] to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">voxel_coord</td><td>The converted voxel coordinates (bottom, front, left corner) in [voxel] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True </dd></dl>

</div>
</div>
<a id="aada2fd9ba3dfa8066e86861c898f4907" name="aada2fd9ba3dfa8066e86861c898f4907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada2fd9ba3dfa8066e86861c898f4907">&#9670;&#160;</a></span>pointToVoxel() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB = se::Safe::On&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246a521c36a31c2762741cf0f8890cbe05e3">se::Safe::On</a>, bool &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::pointToVoxel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert point coordinates in [meter] to its voxel coordinates in [voxel]. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (On by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The point coordinates in [meter] to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">voxel_coord_f</td><td>The converted voxel coordinates in [voxel] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point inside the map, false otherwise </dd></dl>

</div>
</div>
<a id="abcf996b09840b15a247209f9721ddddf" name="abcf996b09840b15a247209f9721ddddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf996b09840b15a247209f9721ddddf">&#9670;&#160;</a></span>pointToVoxel() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246ad15305d7a4e34e02489c74a5ef542f36">se::Safe::Off</a>, bool &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::pointToVoxel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert point coordinates in [meter] to its voxel coordinates in [voxel]. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (On by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_W</td><td>The point coordinates in [meter] to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">voxel_coord_f</td><td>The converted voxel coordinates in [voxel] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True </dd></dl>

</div>
</div>
<a id="ab9c81cb918f28b7499b3374686fccd94" name="ab9c81cb918f28b7499b3374686fccd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c81cb918f28b7499b3374686fccd94">&#9670;&#160;</a></span>pointsToVoxels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB = se::Safe::On&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246a521c36a31c2762741cf0f8890cbe05e3">se::Safe::On</a>, bool &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::pointsToVoxels </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector3i, Eigen::aligned_allocator&lt; Eigen::Vector3i &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>voxel_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a vector of point coordinates in [meter] to its voxel coordinates in [voxel]. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (On by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points_W</td><td>The vector of point coordinates in [meter] to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">voxel_coords</td><td>The vector of converted voxel coordinates in [voxel] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all points are inside the map, false otherwise </dd></dl>

</div>
</div>
<a id="afddb45656cfb13346a94263455178906" name="afddb45656cfb13346a94263455178906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afddb45656cfb13346a94263455178906">&#9670;&#160;</a></span>pointsToVoxels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; SafeB==<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246ad15305d7a4e34e02489c74a5ef542f36">se::Safe::Off</a>, bool &gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::pointsToVoxels </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector3i, Eigen::aligned_allocator&lt; Eigen::Vector3i &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>voxel_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a vector of point coordinates in [meter] to its voxel coordinates in [voxel]. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SafeB</td><td>The parameter turning "contains point" verification on and off (On by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points_W</td><td>The vector of point coordinates in [meter] to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">voxel_coords</td><td>The vector of converted voxel coordinates in [voxel] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True </dd></dl>

</div>
</div>
<a id="a470dac01b6a75e9b12813e43d42f3df8" name="a470dac01b6a75e9b12813e43d42f3df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470dac01b6a75e9b12813e43d42f3df8">&#9670;&#160;</a></span>getOctree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aa8ce519441156a1fb5f47857ed8a7580">OctreeType</a> &amp; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getOctree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the internal <a class="el" href="classse_1_1Octree.html" title="The octree data structure containing the map data.">se::Octree</a>. </p>

</div>
</div>
<a id="a62c3a20df109fc499e7ba067e3d850d7" name="a62c3a20df109fc499e7ba067e3d850d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c3a20df109fc499e7ba067e3d850d7">&#9670;&#160;</a></span>getOctree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aa8ce519441156a1fb5f47857ed8a7580">OctreeType</a> &amp; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::getOctree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a constant reference to the internal <a class="el" href="classse_1_1Octree.html" title="The octree data structure containing the map data.">se::Octree</a>. </p>

</div>
</div>
<a id="a823bd0479d58ba2c47b8a30552604d4d" name="a823bd0479d58ba2c47b8a30552604d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823bd0479d58ba2c47b8a30552604d4d">&#9670;&#160;</a></span>aabb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::AlignedBox3f &amp; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::aabb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the axis-aligned bounding box in the world frame W of the map's allocated leaves. </p>
<p>It can be used to test if some point expressed in the world frame W is contained in it using Eigen::AlignedBox3f::contains(). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0b7daa37882810cbf5226a129afadf30" name="a0b7daa37882810cbf5226a129afadf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7daa37882810cbf5226a129afadf30">&#9670;&#160;</a></span>fld_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::fld_ = FldT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cc7eb4c7e1b03ddfd1d541db001df7c" name="a0cc7eb4c7e1b03ddfd1d541db001df7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc7eb4c7e1b03ddfd1d541db001df7c">&#9670;&#160;</a></span>col_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::col_ = ColB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3aca98cdf2f8f6fc3958ee3266e9441" name="ab3aca98cdf2f8f6fc3958ee3266e9441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3aca98cdf2f8f6fc3958ee3266e9441">&#9670;&#160;</a></span>sem_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::sem_ = SemB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79201beba1d1f55cbbb9cb7757b73cdb" name="a79201beba1d1f55cbbb9cb7757b73cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79201beba1d1f55cbbb9cb7757b73cdb">&#9670;&#160;</a></span>res_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::res_ = ResT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41bd613d17f671ffa518149337075a49" name="a41bd613d17f671ffa518149337075a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bd613d17f671ffa518149337075a49">&#9670;&#160;</a></span>octree_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#aa8ce519441156a1fb5f47857ed8a7580">OctreeType</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::octree_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a567d18a63db64237bb3dd874d53beaf6" name="a567d18a63db64237bb3dd874d53beaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567d18a63db64237bb3dd874d53beaf6">&#9670;&#160;</a></span>resolution_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::resolution_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The resolution of the map. </p>

</div>
</div>
<a id="a05b67bbd5e2cbd5a9ac6d17a18961a2b" name="a05b67bbd5e2cbd5a9ac6d17a18961a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b67bbd5e2cbd5a9ac6d17a18961a2b">&#9670;&#160;</a></span>dimension_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3f <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::dimension_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dimensions of the map. </p>

</div>
</div>
<a id="a0de66378323332d3ae9da3b12d176fcf" name="a0de66378323332d3ae9da3b12d176fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de66378323332d3ae9da3b12d176fcf">&#9670;&#160;</a></span>T_MW_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Isometry3f <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::T_MW_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The transformation from world to map frame. </p>

</div>
</div>
<a id="a2ea100644f9aa9b350b7c56937b379c5" name="a2ea100644f9aa9b350b7c56937b379c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea100644f9aa9b350b7c56937b379c5">&#9670;&#160;</a></span>T_WM_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Isometry3f <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::T_WM_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The transformation from map to world frame. </p>

</div>
</div>
<a id="a7763c604afabd89e02d8e7cb7ec5b9f4" name="a7763c604afabd89e02d8e7cb7ec5b9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7763c604afabd89e02d8e7cb7ec5b9f4">&#9670;&#160;</a></span>lb_M_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3f <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::lb_M_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The lower map bound. </p>

</div>
</div>
<a id="a1b1293febda1829a0c2d3c868e8710d4" name="a1b1293febda1829a0c2d3c868e8710d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1293febda1829a0c2d3c868e8710d4">&#9670;&#160;</a></span>ub_M_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3f <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::ub_M_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The upper map bound. </p>

</div>
</div>
<a id="a8866b5d1dbffc05a9c8bdeb0cf51363f" name="a8866b5d1dbffc05a9c8bdeb0cf51363f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8866b5d1dbffc05a9c8bdeb0cf51363f">&#9670;&#160;</a></span>data_config_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classse_1_1Map_3_01se_1_1Data_3_01FldT_00_01ColB_00_01SemB_01_4_00_01ResT_00_01BlockSize_01_4.html#ad9f55bfb211664276b34c0f18463a87e">DataConfigType</a> <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::data_config_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The configuration of the data. </p>

</div>
</div>
<a id="aa59099b137b26db22833c0c09029c945" name="aa59099b137b26db22833c0c09029c945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59099b137b26db22833c0c09029c945">&#9670;&#160;</a></span>cached_aabb_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AlignedBox3f <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::cached_aabb_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9daef84523801bfbf838ba1266db418a" name="a9daef84523801bfbf838ba1266db418a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daef84523801bfbf838ba1266db418a">&#9670;&#160;</a></span>cached_octree_aabb_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AlignedBox3i <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::cached_octree_aabb_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d1a8494a68035e4aab8fa6a9831c35d" name="a6d1a8494a68035e4aab8fa6a9831c35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1a8494a68035e4aab8fa6a9831c35d">&#9670;&#160;</a></span>corner_rel_steps_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6b">Field</a> FldT, <a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011">Colour</a> ColB, <a class="el" href="namespacese.html#ab5258529307f6264e9c75abfdab3bc68">Semantics</a> SemB, <a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282d">Res</a> ResT, int BlockSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Matrix&lt;float, 3, 8&gt; <a class="el" href="classse_1_1Map.html">se::Map</a>&lt; <a class="el" href="structse_1_1Data.html">se::Data</a>&lt; FldT, ColB, SemB &gt;, ResT, BlockSize &gt;::corner_rel_steps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The eight relative unit corner offsets. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/se/map/<a class="el" href="map_8hpp_source.html">map.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
