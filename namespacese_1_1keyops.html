<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>supereight: se::keyops Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">supereight
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacese.html">se</a></li><li class="navelem"><a class="el" href="namespacese_1_1keyops.html">keyops</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">se::keyops Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af80a8cc6a48399fdf4dab71ef88605e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#af80a8cc6a48399fdf4dab71ef88605e9">is_valid</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a> limit=<a class="el" href="key__util_8hpp.html#a685cc7258c51b8269ed93a40ae430c49">KEY_SCALE_LIMIT</a>)</td></tr>
<tr class="memdesc:af80a8cc6a48399fdf4dab71ef88605e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if a key is valid.  <br /></td></tr>
<tr class="separator:af80a8cc6a48399fdf4dab71ef88605e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5c7750eeb28d21f14e9e0e84ac0276"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a5b5c7750eeb28d21f14e9e0e84ac0276">is_valid</a> (const Eigen::Vector3i &amp;coord)</td></tr>
<tr class="memdesc:a5b5c7750eeb28d21f14e9e0e84ac0276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if a coordinate can be expressed in a key.  <br /></td></tr>
<tr class="separator:a5b5c7750eeb28d21f14e9e0e84ac0276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1657e957f540e6d16f191f06b9821a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#aa1657e957f540e6d16f191f06b9821a3">expand</a> (unsigned long long value)</td></tr>
<tr class="memdesc:aa1657e957f540e6d16f191f06b9821a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands a value that can be expressed by &lt;= 19 bits E.g.  <br /></td></tr>
<tr class="separator:aa1657e957f540e6d16f191f06b9821a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abcbfc1aa7cffa8524c5209a390fd00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a1abcbfc1aa7cffa8524c5209a390fd00">compact</a> (uint64_t value)</td></tr>
<tr class="memdesc:a1abcbfc1aa7cffa8524c5209a390fd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses a value E.g.  <br /></td></tr>
<tr class="separator:a1abcbfc1aa7cffa8524c5209a390fd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac920895b60a58f204d28a4996ce229"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a9ac920895b60a58f204d28a4996ce229">encode_key</a> (const Eigen::Vector3i &amp;coord, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a> scale, <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &amp;key)</td></tr>
<tr class="memdesc:a9ac920895b60a58f204d28a4996ce229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes given coordinates and scale in a key.  <br /></td></tr>
<tr class="separator:a9ac920895b60a58f204d28a4996ce229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9d6341a69fd6dca8e941a4fe5f6619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#aca9d6341a69fd6dca8e941a4fe5f6619">encode_key</a> (const Eigen::Vector3i &amp;coord, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a> scale)</td></tr>
<tr class="memdesc:aca9d6341a69fd6dca8e941a4fe5f6619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes given coordinates and scale in a key.  <br /></td></tr>
<tr class="separator:aca9d6341a69fd6dca8e941a4fe5f6619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ce1d0023cdb5d39b8e4dada755093f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a47ce1d0023cdb5d39b8e4dada755093f">encode_key</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> code, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a> scale, <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &amp;key)</td></tr>
<tr class="memdesc:a47ce1d0023cdb5d39b8e4dada755093f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes given morton code and scale in a key.  <br /></td></tr>
<tr class="separator:a47ce1d0023cdb5d39b8e4dada755093f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6869f7214c4535bb170cb91a04e786de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a6869f7214c4535bb170cb91a04e786de">encode_key</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> code, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a> scale)</td></tr>
<tr class="memdesc:a6869f7214c4535bb170cb91a04e786de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes given morton code and scale in a key.  <br /></td></tr>
<tr class="separator:a6869f7214c4535bb170cb91a04e786de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69b2c4a86f49825dfb13b7b6e523611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#ae69b2c4a86f49825dfb13b7b6e523611">decode_key</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key, Eigen::Vector3i &amp;coord, <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">scale_t</a> &amp;scale)</td></tr>
<tr class="memdesc:ae69b2c4a86f49825dfb13b7b6e523611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the 3D coordinates and scale from a given key.  <br /></td></tr>
<tr class="separator:ae69b2c4a86f49825dfb13b7b6e523611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8584cddcd469752920e5cff0622a195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#ac8584cddcd469752920e5cff0622a195">encode_code</a> (const Eigen::Vector3i &amp;coord, <a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> &amp;code)</td></tr>
<tr class="memdesc:ac8584cddcd469752920e5cff0622a195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Morton code for given x,y,z coordinates.  <br /></td></tr>
<tr class="separator:ac8584cddcd469752920e5cff0622a195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dceece60b1080a555d31d5f538ef73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a91dceece60b1080a555d31d5f538ef73">encode_code</a> (const Eigen::Vector3i &amp;coord)</td></tr>
<tr class="memdesc:a91dceece60b1080a555d31d5f538ef73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Morton code for given x,y,z coordinates.  <br /></td></tr>
<tr class="separator:a91dceece60b1080a555d31d5f538ef73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5e8f681cc54e9b3cb7746f8f2c35a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#ade5e8f681cc54e9b3cb7746f8f2c35a0">decode_code</a> (const <a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> code, Eigen::Vector3i &amp;coord)</td></tr>
<tr class="memdesc:ade5e8f681cc54e9b3cb7746f8f2c35a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the x,y,z coordinates for a given Morton code.  <br /></td></tr>
<tr class="separator:ade5e8f681cc54e9b3cb7746f8f2c35a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4579290c7f4264b3cc04282b1306a7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#a26de076dad6d4a75111a1e0c5cf21b7d">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#aa4579290c7f4264b3cc04282b1306a7a">code_to_child_idx</a> (const <a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> code, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">scale_t</a> scale)</td></tr>
<tr class="memdesc:aa4579290c7f4264b3cc04282b1306a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the child index from a Morton code for a given scale.  <br /></td></tr>
<tr class="separator:aa4579290c7f4264b3cc04282b1306a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3bf38ecd3e9c084a498d6526272266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#aac3bf38ecd3e9c084a498d6526272266">key_to_code</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key)</td></tr>
<tr class="memdesc:aac3bf38ecd3e9c084a498d6526272266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a key to only its Morton code.  <br /></td></tr>
<tr class="separator:aac3bf38ecd3e9c084a498d6526272266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557782a4cd0ffd0185285ab4d9d56bfd"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a557782a4cd0ffd0185285ab4d9d56bfd">key_to_coord</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key)</td></tr>
<tr class="memdesc:a557782a4cd0ffd0185285ab4d9d56bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a key to only its Morton code.  <br /></td></tr>
<tr class="separator:a557782a4cd0ffd0185285ab4d9d56bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9860dcc7434786e67d5b617907d434f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">scale_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#aa9860dcc7434786e67d5b617907d434f">key_to_scale</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key)</td></tr>
<tr class="memdesc:aa9860dcc7434786e67d5b617907d434f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a key to only its scale.  <br /></td></tr>
<tr class="separator:aa9860dcc7434786e67d5b617907d434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2462ad595be28f7afb9a4d24e8343e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a1f2462ad595be28f7afb9a4d24e8343e">key_at_scale</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a> scale, <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &amp;key_at_scale)</td></tr>
<tr class="memdesc:a1f2462ad595be28f7afb9a4d24e8343e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given key, change the key scale and reduce detail from Morton code up to given the scale.  <br /></td></tr>
<tr class="separator:a1f2462ad595be28f7afb9a4d24e8343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79b4d9c0fe820a54ef816a8606d318a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#ab79b4d9c0fe820a54ef816a8606d318a">code_at_scale</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a> scale, <a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> &amp;code_at_scale)</td></tr>
<tr class="memdesc:ab79b4d9c0fe820a54ef816a8606d318a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given key, reduce detail from Morton code up to given a scale.  <br /></td></tr>
<tr class="separator:ab79b4d9c0fe820a54ef816a8606d318a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee93834878a451140688da2c23d6424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#aaee93834878a451140688da2c23d6424">parent_key</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key, <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &amp;parent_key)</td></tr>
<tr class="memdesc:aaee93834878a451140688da2c23d6424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the direct parent key for a given key.  <br /></td></tr>
<tr class="separator:aaee93834878a451140688da2c23d6424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fe7e2e0444a149e429866a9c22edc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a77fe7e2e0444a149e429866a9c22edc1">block_key</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a> max_block_scale)</td></tr>
<tr class="memdesc:a77fe7e2e0444a149e429866a9c22edc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the voxel position detail within a block from a key while maintainig the scale information.  <br /></td></tr>
<tr class="separator:a77fe7e2e0444a149e429866a9c22edc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052389c8f9ea3d646ac265f20caf3ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a052389c8f9ea3d646ac265f20caf3ff6">block_code</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a> max_block_scale)</td></tr>
<tr class="memdesc:a052389c8f9ea3d646ac265f20caf3ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the voxel position detail within a block from a code.  <br /></td></tr>
<tr class="separator:a052389c8f9ea3d646ac265f20caf3ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f7114a0679a7ab4c21b9e823623f81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a61f7114a0679a7ab4c21b9e823623f81">parent_to_child_key</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> <a class="el" href="namespacese_1_1keyops.html#aaee93834878a451140688da2c23d6424">parent_key</a>, const <a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> <a class="el" href="namespacese_1_1keyops.html#ab79b4d9c0fe820a54ef816a8606d318a">code_at_scale</a>, <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &amp;child_key)</td></tr>
<tr class="memdesc:a61f7114a0679a7ab4c21b9e823623f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the child key for a given parent key and child index.  <br /></td></tr>
<tr class="separator:a61f7114a0679a7ab4c21b9e823623f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645c7bf7dcf65a4c7eadbcbb29230ff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a645c7bf7dcf65a4c7eadbcbb29230ff4">is_child</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> <a class="el" href="namespacese_1_1keyops.html#aaee93834878a451140688da2c23d6424">parent_key</a>, const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> child_key)</td></tr>
<tr class="memdesc:a645c7bf7dcf65a4c7eadbcbb29230ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if a key is a child of a different key.  <br /></td></tr>
<tr class="separator:a645c7bf7dcf65a4c7eadbcbb29230ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e18021d4043db73745c7377566fd14e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a7e18021d4043db73745c7377566fd14e">is_siblings</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> sibling_1_key, const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> sibling_2_key)</td></tr>
<tr class="memdesc:a7e18021d4043db73745c7377566fd14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if two keys encode sibling nodes/voxels.  <br /></td></tr>
<tr class="separator:a7e18021d4043db73745c7377566fd14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b91516c14648f17909f227756f4b1a8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#a0a5b0636d2ffdc8d91314dab888c2b9f">Sort</a>  = Sort::SmallToLarge&gt; </td></tr>
<tr class="memitem:a9b91516c14648f17909f227756f4b1a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a9b91516c14648f17909f227756f4b1a8">sort_keys</a> (std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;keys)</td></tr>
<tr class="memdesc:a9b91516c14648f17909f227756f4b1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorting template.  <br /></td></tr>
<tr class="separator:a9b91516c14648f17909f227756f4b1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6fa54129c2a807f2da67b05a980f2d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7d6fa54129c2a807f2da67b05a980f2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a7d6fa54129c2a807f2da67b05a980f2d">sort_keys&lt; Sort::SmallToLarge &gt;</a> (std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;keys)</td></tr>
<tr class="memdesc:a7d6fa54129c2a807f2da67b05a980f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the keys from smallest to largest.  <br /></td></tr>
<tr class="separator:a7d6fa54129c2a807f2da67b05a980f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0778e7301bc2d6846b57c47e177e5dad"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0778e7301bc2d6846b57c47e177e5dad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a0778e7301bc2d6846b57c47e177e5dad">sort_keys&lt; Sort::LargeToSmall &gt;</a> (std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;keys)</td></tr>
<tr class="memdesc:a0778e7301bc2d6846b57c47e177e5dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the keys from largest to smallest.  <br /></td></tr>
<tr class="separator:a0778e7301bc2d6846b57c47e177e5dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549d7982955fb2ec647e0c14057c5483"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </td></tr>
<tr class="memitem:a549d7982955fb2ec647e0c14057c5483"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a549d7982955fb2ec647e0c14057c5483">unique_keys</a> (const std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;keys, std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;unique_keys)</td></tr>
<tr class="memdesc:a549d7982955fb2ec647e0c14057c5483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter keys based on the whole key (i.e.  <br /></td></tr>
<tr class="separator:a549d7982955fb2ec647e0c14057c5483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cdc4cc2964d612080fb40b0fa05729"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </td></tr>
<tr class="memitem:ab5cdc4cc2964d612080fb40b0fa05729"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#ab5cdc4cc2964d612080fb40b0fa05729">unique_codes</a> (const std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;keys, std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;<a class="el" href="namespacese_1_1keyops.html#a549d7982955fb2ec647e0c14057c5483">unique_keys</a>)</td></tr>
<tr class="memdesc:ab5cdc4cc2964d612080fb40b0fa05729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter keys based on their code and keep the key with the smallest scale.  <br /></td></tr>
<tr class="separator:ab5cdc4cc2964d612080fb40b0fa05729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d301d9fd36e876a4353c3459e4f433"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </td></tr>
<tr class="memitem:a59d301d9fd36e876a4353c3459e4f433"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a59d301d9fd36e876a4353c3459e4f433">unique_allocation</a> (const std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;keys, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">scale_t</a> max_block_scale, std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;<a class="el" href="namespacese_1_1keyops.html#a549d7982955fb2ec647e0c14057c5483">unique_keys</a>)</td></tr>
<tr class="memdesc:a59d301d9fd36e876a4353c3459e4f433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter keys based on unique allocation.  <br /></td></tr>
<tr class="separator:a59d301d9fd36e876a4353c3459e4f433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7e90e7cd9fd9208f2bb0705534aace"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </td></tr>
<tr class="memitem:a8f7e90e7cd9fd9208f2bb0705534aace"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a8f7e90e7cd9fd9208f2bb0705534aace">unique_at_scale</a> (const std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;keys, const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a> scale, std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;<a class="el" href="namespacese_1_1keyops.html#a549d7982955fb2ec647e0c14057c5483">unique_keys</a>)</td></tr>
<tr class="memdesc:a8f7e90e7cd9fd9208f2bb0705534aace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter keys at a given scale.  <br /></td></tr>
<tr class="separator:a8f7e90e7cd9fd9208f2bb0705534aace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6ef016c197d8396a4a89edba446004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a1c6ef016c197d8396a4a89edba446004">face_neighbours</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key, std::array&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>, 6 &gt; face_neighbour_keys)</td></tr>
<tr class="memdesc:a1c6ef016c197d8396a4a89edba446004"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: 6-connectivity + centre.  <br /></td></tr>
<tr class="separator:a1c6ef016c197d8396a4a89edba446004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa09b66b607db80b64306dbde3844d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#aaa09b66b607db80b64306dbde3844d51">neighbours</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key, std::array&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>, 26 &gt; neighbour_keys)</td></tr>
<tr class="memdesc:aaa09b66b607db80b64306dbde3844d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: 26-connectivity.  <br /></td></tr>
<tr class="separator:aaa09b66b607db80b64306dbde3844d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6158803d750d05c0c4a0fd99fe5e91b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1keyops.html#a6158803d750d05c0c4a0fd99fe5e91b2">siblings</a> (const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> key, std::array&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>, 8 &gt; sibling_keys)</td></tr>
<tr class="memdesc:a6158803d750d05c0c4a0fd99fe5e91b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: 4 siblings (includes key)  <br /></td></tr>
<tr class="separator:a6158803d750d05c0c4a0fd99fe5e91b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af80a8cc6a48399fdf4dab71ef88605e9" name="af80a8cc6a48399fdf4dab71ef88605e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80a8cc6a48399fdf4dab71ef88605e9">&#9670;&#160;</a></span>is_valid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool se::keyops::is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a>&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="key__util_8hpp.html#a685cc7258c51b8269ed93a40ae430c49">KEY_SCALE_LIMIT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify if a key is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to be varified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the key is valid, False otherwise. </dd></dl>

</div>
</div>
<a id="a5b5c7750eeb28d21f14e9e0e84ac0276" name="a5b5c7750eeb28d21f14e9e0e84ac0276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5c7750eeb28d21f14e9e0e84ac0276">&#9670;&#160;</a></span>is_valid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool se::keyops::is_valid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>coord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify if a coordinate can be expressed in a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>The 3D coordinates to be varified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the coordinates are valid, False otherwise. </dd></dl>

</div>
</div>
<a id="aa1657e957f540e6d16f191f06b9821a3" name="aa1657e957f540e6d16f191f06b9821a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1657e957f540e6d16f191f06b9821a3">&#9670;&#160;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> se::keyops::expand </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expands a value that can be expressed by &lt;= 19 bits E.g. </p>
<p>DCBA =&gt; 00D 00C 00B 00A</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be expanded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expanded value </dd></dl>

</div>
</div>
<a id="a1abcbfc1aa7cffa8524c5209a390fd00" name="a1abcbfc1aa7cffa8524c5209a390fd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abcbfc1aa7cffa8524c5209a390fd00">&#9670;&#160;</a></span>compact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> se::keyops::compact </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses a value E.g. </p>
<p>00D 00C 00B 00A =&gt; DCBA</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be compressed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The compressed value </dd></dl>

</div>
</div>
<a id="a9ac920895b60a58f204d28a4996ce229" name="a9ac920895b60a58f204d28a4996ce229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac920895b60a58f204d28a4996ce229">&#9670;&#160;</a></span>encode_key() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool se::keyops::encode_key </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes given coordinates and scale in a key. </p>
<dl class="section note"><dt>Note</dt><dd>The key will only hold as much detail as possible at the given scale. I.e. if the coordinates are at a higher resolution than the scale can represent, the details will be lost.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>The coordinates to be encoded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale at which to encode the coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>The encoded key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if no detail is lost, false otherwise </dd></dl>

</div>
</div>
<a id="aca9d6341a69fd6dca8e941a4fe5f6619" name="aca9d6341a69fd6dca8e941a4fe5f6619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9d6341a69fd6dca8e941a4fe5f6619">&#9670;&#160;</a></span>encode_key() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> se::keyops::encode_key </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a>&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes given coordinates and scale in a key. </p>
<dl class="section note"><dt>Note</dt><dd>The key will only hold as much detail as possible at the given scale. I.e. if the coordinates are at a higher resolution than the scale can represent, the details will be lost.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>The coordinates to be encoded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale at which to encode the coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The encoded key </dd></dl>

</div>
</div>
<a id="a47ce1d0023cdb5d39b8e4dada755093f" name="a47ce1d0023cdb5d39b8e4dada755093f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ce1d0023cdb5d39b8e4dada755093f">&#9670;&#160;</a></span>encode_key() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool se::keyops::encode_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes given morton code and scale in a key. </p>
<dl class="section note"><dt>Note</dt><dd>The key will only hold as much detail as possible at the given scale. I.e. if the code is at a higher resolution than the scale can represent, the details will be lost.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>The coordinates to be encoded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale at which to encode the cooridinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>The encoded key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if no detail is lost, false otherwise </dd></dl>

</div>
</div>
<a id="a6869f7214c4535bb170cb91a04e786de" name="a6869f7214c4535bb170cb91a04e786de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6869f7214c4535bb170cb91a04e786de">&#9670;&#160;</a></span>encode_key() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> se::keyops::encode_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a>&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes given morton code and scale in a key. </p>
<dl class="section note"><dt>Note</dt><dd>The key will only hold as much detail as possible at the given scale. I.e. if the code is at a higher resolution than the scale can represent, the details will be lost.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>The coordinates to be encoded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale at which to encode the cooridinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The encoded key </dd></dl>

</div>
</div>
<a id="ae69b2c4a86f49825dfb13b7b6e523611" name="ae69b2c4a86f49825dfb13b7b6e523611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69b2c4a86f49825dfb13b7b6e523611">&#9670;&#160;</a></span>decode_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::decode_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">scale_t</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the 3D coordinates and scale from a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to be encoded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coord</td><td>The 3D coordinates of the key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scale</td><td>The the scale of the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8584cddcd469752920e5cff0622a195" name="ac8584cddcd469752920e5cff0622a195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8584cddcd469752920e5cff0622a195">&#9670;&#160;</a></span>encode_code() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::encode_code </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> &amp;&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Morton code for given x,y,z coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>The coordinates to be encoded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>The Morten code representing the coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91dceece60b1080a555d31d5f538ef73" name="a91dceece60b1080a555d31d5f538ef73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dceece60b1080a555d31d5f538ef73">&#9670;&#160;</a></span>encode_code() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> se::keyops::encode_code </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>coord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Morton code for given x,y,z coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>The coordinates to be encoded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>The Morten code representing the coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade5e8f681cc54e9b3cb7746f8f2c35a0" name="ade5e8f681cc54e9b3cb7746f8f2c35a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5e8f681cc54e9b3cb7746f8f2c35a0">&#9670;&#160;</a></span>decode_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::decode_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the x,y,z coordinates for a given Morton code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>The code to be encoded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coord</td><td>The coordinates representing the Morton code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4579290c7f4264b3cc04282b1306a7a" name="aa4579290c7f4264b3cc04282b1306a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4579290c7f4264b3cc04282b1306a7a">&#9670;&#160;</a></span>code_to_child_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#a26de076dad6d4a75111a1e0c5cf21b7d">idx_t</a> se::keyops::code_to_child_idx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">scale_t</a>&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the child index from a Morton code for a given scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The full Morton code </td></tr>
    <tr><td class="paramname">scale</td><td>The scale at which to extract the child index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child index </dd></dl>

</div>
</div>
<a id="aac3bf38ecd3e9c084a498d6526272266" name="aac3bf38ecd3e9c084a498d6526272266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3bf38ecd3e9c084a498d6526272266">&#9670;&#160;</a></span>key_to_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> se::keyops::key_to_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce a key to only its Morton code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key containing the Morton code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Morton code of the key </dd></dl>

</div>
</div>
<a id="a557782a4cd0ffd0185285ab4d9d56bfd" name="a557782a4cd0ffd0185285ab4d9d56bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557782a4cd0ffd0185285ab4d9d56bfd">&#9670;&#160;</a></span>key_to_coord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3i se::keyops::key_to_coord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce a key to only its Morton code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key containing the Morton code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Morton code of the key </dd></dl>

</div>
</div>
<a id="aa9860dcc7434786e67d5b617907d434f" name="aa9860dcc7434786e67d5b617907d434f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9860dcc7434786e67d5b617907d434f">&#9670;&#160;</a></span>key_to_scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">scale_t</a> se::keyops::key_to_scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce a key to only its scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key containing the Morton code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scale of the key </dd></dl>

</div>
</div>
<a id="a1f2462ad595be28f7afb9a4d24e8343e" name="a1f2462ad595be28f7afb9a4d24e8343e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2462ad595be28f7afb9a4d24e8343e">&#9670;&#160;</a></span>key_at_scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool se::keyops::key_at_scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key_at_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given key, change the key scale and reduce detail from Morton code up to given the scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale the key should be changed to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_at_scale</td><td>The modified key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the key can be reduced to the given scale, False otherwise </dd></dl>

</div>
</div>
<a id="ab79b4d9c0fe820a54ef816a8606d318a" name="ab79b4d9c0fe820a54ef816a8606d318a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79b4d9c0fe820a54ef816a8606d318a">&#9670;&#160;</a></span>code_at_scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool se::keyops::code_at_scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> &amp;&#160;</td>
          <td class="paramname"><em>code_at_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given key, reduce detail from Morton code up to given a scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key containing the code to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale the code should be reduced to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code_at_scale</td><td>The modified code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the code can be reduced to the given scale, False otherwise </dd></dl>

</div>
</div>
<a id="aaee93834878a451140688da2c23d6424" name="aaee93834878a451140688da2c23d6424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee93834878a451140688da2c23d6424">&#9670;&#160;</a></span>parent_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::parent_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>parent_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the direct parent key for a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to compute the direct parent from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_key</td><td>The parent key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77fe7e2e0444a149e429866a9c22edc1" name="a77fe7e2e0444a149e429866a9c22edc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fe7e2e0444a149e429866a9c22edc1">&#9670;&#160;</a></span>block_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> se::keyops::block_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a>&#160;</td>
          <td class="paramname"><em>max_block_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the voxel position detail within a block from a key while maintainig the scale information. </p>
<dl class="section note"><dt>Note</dt><dd>The key will not be modified if a node key is handed to it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to be filtered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_block_scale</td><td>The maximum scale of a block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The filtered block key </dd></dl>

</div>
</div>
<a id="a052389c8f9ea3d646ac265f20caf3ff6" name="a052389c8f9ea3d646ac265f20caf3ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052389c8f9ea3d646ac265f20caf3ff6">&#9670;&#160;</a></span>block_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a> se::keyops::block_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a>&#160;</td>
          <td class="paramname"><em>max_block_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the voxel position detail within a block from a code. </p>
<dl class="section note"><dt>Note</dt><dd>The code will not be modified if a node key is handed to it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to be filtered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_block_scale</td><td>The maximum scale of a block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The filtered block code </dd></dl>

</div>
</div>
<a id="a61f7114a0679a7ab4c21b9e823623f81" name="a61f7114a0679a7ab4c21b9e823623f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f7114a0679a7ab4c21b9e823623f81">&#9670;&#160;</a></span>parent_to_child_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::parent_to_child_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>parent_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31">se::code_t</a>&#160;</td>
          <td class="paramname"><em>code_at_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>child_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the child key for a given parent key and child index. </p>
<dl class="section note"><dt>Note</dt><dd><code>code_at_scale</code> is equivalent to <code><a class="el" href="namespacese.html#a251d1525f3231df4756bc4fa5f94bc31" title="The type of the Morton code.">se::code_t(child_idx)</a></code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_key</td><td>The key of parent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code_at_scale</td><td>The morton code segment at the scale e.g. 000, 001, ... , 110, ... , 111 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">child_key</td><td>The key of the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a645c7bf7dcf65a4c7eadbcbb29230ff4" name="a645c7bf7dcf65a4c7eadbcbb29230ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645c7bf7dcf65a4c7eadbcbb29230ff4">&#9670;&#160;</a></span>is_child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool se::keyops::is_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>parent_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>child_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify if a key is a child of a different key. </p>
<dl class="section note"><dt>Note</dt><dd>This function is not limited by a single scale change. If parent_key expresses any ancestor of child_key the function will return True.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_key</td><td>The key of the parent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child_key</td><td>The key of the potential child</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if child_key expresses a child node/voxel of parent_key </dd></dl>

</div>
</div>
<a id="a7e18021d4043db73745c7377566fd14e" name="a7e18021d4043db73745c7377566fd14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e18021d4043db73745c7377566fd14e">&#9670;&#160;</a></span>is_siblings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool se::keyops::is_siblings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>sibling_1_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>sibling_2_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify if two keys encode sibling nodes/voxels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sibling_1_key</td><td>The key of the first sibling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sibling_2_key</td><td>The key of the second sibling</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the keys express siblings nodes/voxels, False otherwise </dd></dl>

</div>
</div>
<a id="a9b91516c14648f17909f227756f4b1a8" name="a9b91516c14648f17909f227756f4b1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b91516c14648f17909f227756f4b1a8">&#9670;&#160;</a></span>sort_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#a0a5b0636d2ffdc8d91314dab888c2b9f">Sort</a>  = Sort::SmallToLarge&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::sort_keys </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorting template. </p>
<p>Default small to larger key sorting. </p>

</div>
</div>
<a id="a7d6fa54129c2a807f2da67b05a980f2d" name="a7d6fa54129c2a807f2da67b05a980f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6fa54129c2a807f2da67b05a980f2d">&#9670;&#160;</a></span>sort_keys&lt; Sort::SmallToLarge &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacese_1_1keyops.html#a9b91516c14648f17909f227756f4b1a8">se::keyops::sort_keys</a>&lt; <a class="el" href="namespacese.html#a0a5b0636d2ffdc8d91314dab888c2b9fa1fb52f7ade6030e6c7e6e2b037a092f9">Sort::SmallToLarge</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the keys from smallest to largest. </p>
<ul>
<li>At a given scale a dimension will be prioritised z &gt; y &gt; z (MSB &gt; LSB)</li>
<li>For equivalent Morton codes smaller scales will be prioritised over larger scales (child first).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[in/out]</td><td>keys The keys to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0778e7301bc2d6846b57c47e177e5dad" name="a0778e7301bc2d6846b57c47e177e5dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0778e7301bc2d6846b57c47e177e5dad">&#9670;&#160;</a></span>sort_keys&lt; Sort::LargeToSmall &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacese_1_1keyops.html#a9b91516c14648f17909f227756f4b1a8">se::keyops::sort_keys</a>&lt; <a class="el" href="namespacese.html#a0a5b0636d2ffdc8d91314dab888c2b9fad52db6ba828dcfd565525cb8edbfeb97">Sort::LargeToSmall</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the keys from largest to smallest. </p>
<ul>
<li>At a given scale a dimension will be prioritised z &gt; y &gt; z (MSB &gt; LSB)</li>
<li>For equivalent Morton codes larger scales will be prioritised over smaller scales (parent first).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[in/out]</td><td>keys </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a549d7982955fb2ec647e0c14057c5483" name="a549d7982955fb2ec647e0c14057c5483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549d7982955fb2ec647e0c14057c5483">&#9670;&#160;</a></span>unique_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::unique_keys </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unique_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter keys based on the whole key (i.e. </p>
<p>code and scale).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>The keys to be filtered </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unique_keys</td><td>The filtered unique keys </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5cdc4cc2964d612080fb40b0fa05729" name="ab5cdc4cc2964d612080fb40b0fa05729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cdc4cc2964d612080fb40b0fa05729">&#9670;&#160;</a></span>unique_codes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::unique_codes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unique_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter keys based on their code and keep the key with the smallest scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>The keys to be filtered </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unique_keys</td><td>The filtered unique keys </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59d301d9fd36e876a4353c3459e4f433" name="a59d301d9fd36e876a4353c3459e4f433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d301d9fd36e876a4353c3459e4f433">&#9670;&#160;</a></span>unique_allocation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::unique_allocation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">scale_t</a>&#160;</td>
          <td class="paramname"><em>max_block_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unique_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter keys based on unique allocation. </p>
<ul>
<li>Parents will be filtered out</li>
<li>Voxel position detail within a block will be filtered out</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>The keys to be filtered </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unique_keys</td><td>The filtered unique keys </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f7e90e7cd9fd9208f2bb0705534aace" name="a8f7e90e7cd9fd9208f2bb0705534aace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7e90e7cd9fd9208f2bb0705534aace">&#9670;&#160;</a></span>unique_at_scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacese.html#ad4d57e3dd5e589e6c1710ab1de94b246">se::Safe</a> SafeB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::unique_at_scale </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac1e68429daa88ed6435e5fe5edcac9f5">se::scale_t</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unique_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter keys at a given scale. </p>
<ul>
<li>Keys at finer scales will be moved to the given scale.</li>
<li>Keys at coarser scales will be removed.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>The keys to be filtered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale at which to filter the keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unique_keys</td><td>The filtered unique keys </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c6ef016c197d8396a4a89edba446004" name="a1c6ef016c197d8396a4a89edba446004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6ef016c197d8396a4a89edba446004">&#9670;&#160;</a></span>face_neighbours()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::face_neighbours </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>, 6 &gt;&#160;</td>
          <td class="paramname"><em>face_neighbour_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: 6-connectivity + centre. </p>
<p>Compute the 6 face neighbour keys of a given key (excluding the key itself)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key of which to get the neighbours from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">face_neighbour_keys</td><td>The 6 face neighbour keys </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa09b66b607db80b64306dbde3844d51" name="aaa09b66b607db80b64306dbde3844d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa09b66b607db80b64306dbde3844d51">&#9670;&#160;</a></span>neighbours()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::neighbours </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>, 26 &gt;&#160;</td>
          <td class="paramname"><em>neighbour_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: 26-connectivity. </p>
<p>Compute the 26 neighbour keys of a given key (excluding the key itself)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key of which to get the neighbours from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighbour_keys</td><td>The 26 neighbour keys </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6158803d750d05c0c4a0fd99fe5e91b2" name="a6158803d750d05c0c4a0fd99fe5e91b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6158803d750d05c0c4a0fd99fe5e91b2">&#9670;&#160;</a></span>siblings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void se::keyops::siblings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespacese.html#ac3e325c99164137446d8101df34c22fb">se::key_t</a>, 8 &gt;&#160;</td>
          <td class="paramname"><em>sibling_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: 4 siblings (includes key) </p>
<p>Get the 7 sibling keys of a given key (including the key itself)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key of which to get the siblings from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sibling_keys</td><td>The eight sibling keys </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
