<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>supereight: se::visitor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">supereight
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacese.html">se</a></li><li class="navelem"><a class="el" href="namespacese_1_1visitor.html">visitor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">se::visitor Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaad44fe4310d7323358d7ad8549c6ca0"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:aaad44fe4310d7323358d7ad8549c6ca0"><td class="memTemplItemLeft" align="right" valign="top">OctreeT::DataType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#aaad44fe4310d7323358d7ad8549c6ca0">getData</a> (const OctreeT &amp;octree, const Eigen::Vector3i &amp;voxel_coord)</td></tr>
<tr class="memdesc:aaad44fe4310d7323358d7ad8549c6ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single/multi-res get data functions.  <br /></td></tr>
<tr class="separator:aaad44fe4310d7323358d7ad8549c6ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe67985ca5372d6bb37859cb8174385"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT , typename BlockT &gt; </td></tr>
<tr class="memitem:a8fe67985ca5372d6bb37859cb8174385"><td class="memTemplItemLeft" align="right" valign="top">OctreeT::DataType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a8fe67985ca5372d6bb37859cb8174385">getData</a> (const OctreeT &amp;octree, BlockT *block_ptr, const Eigen::Vector3i &amp;voxel_coord)</td></tr>
<tr class="memdesc:a8fe67985ca5372d6bb37859cb8174385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the voxel data for a given coordinate.  <br /></td></tr>
<tr class="separator:a8fe67985ca5372d6bb37859cb8174385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4549d25ef3c1ed0d28fe2c6e3433387b"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a4549d25ef3c1ed0d28fe2c6e3433387b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, typename OctreeT::DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a4549d25ef3c1ed0d28fe2c6e3433387b">getData</a> (const OctreeT &amp;octree, const Eigen::Vector3i &amp;voxel_coord, const int scale_desired, int &amp;scale_returned)</td></tr>
<tr class="memdesc:a4549d25ef3c1ed0d28fe2c6e3433387b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-res get data functions.  <br /></td></tr>
<tr class="separator:a4549d25ef3c1ed0d28fe2c6e3433387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c872c5768c224d678d96e6f2d0a803"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT , typename BlockT &gt; </td></tr>
<tr class="memitem:ab9c872c5768c224d678d96e6f2d0a803"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, typename OctreeT::DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#ab9c872c5768c224d678d96e6f2d0a803">getData</a> (const OctreeT &amp;octree, BlockT *block_ptr, const Eigen::Vector3i &amp;voxel_coord, const int scale_desired, int &amp;scale_returned)</td></tr>
<tr class="memdesc:ab9c872c5768c224d678d96e6f2d0a803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the voxel data for a given coordinate and desired scale.  <br /></td></tr>
<tr class="separator:ab9c872c5768c224d678d96e6f2d0a803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8794705cddfd87891d30f68eaa7ed59f"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a8794705cddfd87891d30f68eaa7ed59f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::DataType::fld_==<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6ba9b4b1d446cebefa9cf1d6c6d7ef17d70">se::Field::Occupancy</a>, typename OctreeT::DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a8794705cddfd87891d30f68eaa7ed59f">getMinData</a> (const OctreeT &amp;octree, const Eigen::Vector3i &amp;voxel_coord, const int scale_desired)</td></tr>
<tr class="memdesc:a8794705cddfd87891d30f68eaa7ed59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the min occupancy data at a given scale.  <br /></td></tr>
<tr class="separator:a8794705cddfd87891d30f68eaa7ed59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5f9e987e1044adbd4481bc44af2f63"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a6f5f9e987e1044adbd4481bc44af2f63"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::DataType::fld_==<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6ba9b4b1d446cebefa9cf1d6c6d7ef17d70">Field::Occupancy</a>, typename OctreeT::DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a6f5f9e987e1044adbd4481bc44af2f63">getMaxData</a> (const OctreeT &amp;octree, const Eigen::Vector3i &amp;voxel_coord, const int scale_desired)</td></tr>
<tr class="memdesc:a6f5f9e987e1044adbd4481bc44af2f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the max occupancy data at a given scale.  <br /></td></tr>
<tr class="separator:a6f5f9e987e1044adbd4481bc44af2f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa4ca4fc9c27d2d11a196dbd214b7b1"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:acaa4ca4fc9c27d2d11a196dbd214b7b1"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#acaa4ca4fc9c27d2d11a196dbd214b7b1">getField</a> (const OctreeT &amp;octree, const Eigen::Vector3i &amp;voxel_coord)</td></tr>
<tr class="memdesc:acaa4ca4fc9c27d2d11a196dbd214b7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single/Multi-res get field functions.  <br /></td></tr>
<tr class="separator:acaa4ca4fc9c27d2d11a196dbd214b7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fb8b7d0d89cc568532863c410b8112"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT , typename BlockT &gt; </td></tr>
<tr class="memitem:aa2fb8b7d0d89cc568532863c410b8112"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#aa2fb8b7d0d89cc568532863c410b8112">getField</a> (const OctreeT &amp;octree, BlockT *block_ptr, const Eigen::Vector3i &amp;voxel_coord)</td></tr>
<tr class="memdesc:aa2fb8b7d0d89cc568532863c410b8112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the field value for a given coordinate.  <br /></td></tr>
<tr class="separator:aa2fb8b7d0d89cc568532863c410b8112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f41e5ef7de9af5ff1d6b7f6acab446"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:ac9f41e5ef7de9af5ff1d6b7f6acab446"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#ac9f41e5ef7de9af5ff1d6b7f6acab446">getField</a> (const OctreeT &amp;octree, const Eigen::Vector3i &amp;voxel_coord, const int scale_desired, int &amp;scale_returned)</td></tr>
<tr class="memdesc:ac9f41e5ef7de9af5ff1d6b7f6acab446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-res get field functions.  <br /></td></tr>
<tr class="separator:ac9f41e5ef7de9af5ff1d6b7f6acab446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7685ea5a7222975869f387aa0a82718c"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT , typename BlockT &gt; </td></tr>
<tr class="memitem:a7685ea5a7222975869f387aa0a82718c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a7685ea5a7222975869f387aa0a82718c">getField</a> (const OctreeT &amp;octree, BlockT *block_ptr, const Eigen::Vector3i &amp;voxel_coord, const int scale_desired, int &amp;scale_returned)</td></tr>
<tr class="memdesc:a7685ea5a7222975869f387aa0a82718c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the field value for a given coordinate and desired scale.  <br /></td></tr>
<tr class="separator:a7685ea5a7222975869f387aa0a82718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a1745b743f945af1d170e1f8fdfc7e"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT , typename ValidF , typename GetF &gt; </td></tr>
<tr class="memitem:a60a1745b743f945af1d170e1f8fdfc7e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; std::invoke_result_t&lt; GetF, typename OctreeT::DataType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a60a1745b743f945af1d170e1f8fdfc7e">getInterp</a> (const OctreeT &amp;octree, const Eigen::Vector3f &amp;voxel_coord_f, ValidF valid, GetF get, const int desired_scale=0, int *const returned_scale=nullptr)</td></tr>
<tr class="memdesc:a60a1745b743f945af1d170e1f8fdfc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a member of <a class="el" href="classse_1_1Octree.html#a168234bec7fde15d8568c1958fd70075">se::Octree::DataType</a> at the supplied voxel coordinates and desired scale.  <br /></td></tr>
<tr class="separator:a60a1745b743f945af1d170e1f8fdfc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c161e98da7a59fe1a921561f4d21c4"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT , typename ValidF , typename GetF &gt; </td></tr>
<tr class="memitem:ad6c161e98da7a59fe1a921561f4d21c4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">Res::Single</a>, std::optional&lt; std::invoke_result_t&lt; GetF, typename OctreeT::DataType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#ad6c161e98da7a59fe1a921561f4d21c4">getInterp</a> (const OctreeT &amp;octree, const Eigen::Vector3f &amp;voxel_coord_f, ValidF valid, GetF get)</td></tr>
<tr class="memdesc:ad6c161e98da7a59fe1a921561f4d21c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad6c161e98da7a59fe1a921561f4d21c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fde253b575cc45d6e390c9c6fee4ca6"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a9fde253b575cc45d6e390c9c6fee4ca6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a9fde253b575cc45d6e390c9c6fee4ca6">getFieldInterp</a> (const OctreeT &amp;octree, const Eigen::Vector3f &amp;voxel_coord_f, const int desired_scale=0, int *const returned_scale=nullptr)</td></tr>
<tr class="memdesc:a9fde253b575cc45d6e390c9c6fee4ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the field at the supplied voxel coordinates and desired scale.  <br /></td></tr>
<tr class="separator:a9fde253b575cc45d6e390c9c6fee4ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0c95c2fc108b10e3b39475b1622bd6"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a9e0c95c2fc108b10e3b39475b1622bd6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">Res::Single</a>, std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a9e0c95c2fc108b10e3b39475b1622bd6">getFieldInterp</a> (const OctreeT &amp;octree, const Eigen::Vector3f &amp;voxel_coord_f)</td></tr>
<tr class="memdesc:a9e0c95c2fc108b10e3b39475b1622bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9e0c95c2fc108b10e3b39475b1622bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467b0bef5ca2d08dfe4afb004a07f130"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a467b0bef5ca2d08dfe4afb004a07f130"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a> &amp;&amp;OctreeT::col_==<a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011a521c36a31c2762741cf0f8890cbe05e3">Colour::On</a>, std::optional&lt; <a class="el" href="namespacese.html#a3773d59e592d829621175de16f791821">colour_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a467b0bef5ca2d08dfe4afb004a07f130">getColourInterp</a> (const OctreeT &amp;octree, const Eigen::Vector3f &amp;voxel_coord_f, const int desired_scale=0, int *const returned_scale=nullptr)</td></tr>
<tr class="memdesc:a467b0bef5ca2d08dfe4afb004a07f130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the colour at the supplied voxel coordinates and desired scale.  <br /></td></tr>
<tr class="separator:a467b0bef5ca2d08dfe4afb004a07f130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7b2de68262c0ac0867d543b344ff22"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a1f7b2de68262c0ac0867d543b344ff22"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">Res::Single</a> &amp;&amp;OctreeT::col_==<a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011a521c36a31c2762741cf0f8890cbe05e3">Colour::On</a>, std::optional&lt; <a class="el" href="namespacese.html#a3773d59e592d829621175de16f791821">colour_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a1f7b2de68262c0ac0867d543b344ff22">getColourInterp</a> (const OctreeT &amp;octree, const Eigen::Vector3f &amp;voxel_coord_f)</td></tr>
<tr class="memdesc:a1f7b2de68262c0ac0867d543b344ff22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1f7b2de68262c0ac0867d543b344ff22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72fcd5a3b1c2970cd13d458004185f6"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:ab72fcd5a3b1c2970cd13d458004185f6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">Res::Single</a>, std::optional&lt; <a class="el" href="namespacese.html#a0ae75653f6cec9dd7b73580a4ddba6f9">field_vec_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#ab72fcd5a3b1c2970cd13d458004185f6">getFieldGrad</a> (const OctreeT &amp;octree, const Eigen::Vector3f &amp;voxel_coord_f)</td></tr>
<tr class="memdesc:ab72fcd5a3b1c2970cd13d458004185f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-res get gradient functions.  <br /></td></tr>
<tr class="separator:ab72fcd5a3b1c2970cd13d458004185f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae013c62a566800918c5dc02e364b7b06"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:ae013c62a566800918c5dc02e364b7b06"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a0ae75653f6cec9dd7b73580a4ddba6f9">field_vec_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#ae013c62a566800918c5dc02e364b7b06">getFieldGrad</a> (const OctreeT &amp;octree, const Eigen::Vector3f &amp;voxel_coord_f)</td></tr>
<tr class="memdesc:ae013c62a566800918c5dc02e364b7b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-res get gradient functions.  <br /></td></tr>
<tr class="separator:ae013c62a566800918c5dc02e364b7b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1e779a33912757222eebb642177ee1"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:acd1e779a33912757222eebb642177ee1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a0ae75653f6cec9dd7b73580a4ddba6f9">field_vec_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#acd1e779a33912757222eebb642177ee1">getFieldGrad</a> (const OctreeT &amp;octree, const Eigen::Vector3f &amp;voxel_coord_f, int &amp;scale_returned)</td></tr>
<tr class="memdesc:acd1e779a33912757222eebb642177ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the field gradient for a given coordinate [float voxel coordinates].  <br /></td></tr>
<tr class="separator:acd1e779a33912757222eebb642177ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d69294f953b8a9d75526df2e30cbd3c"><td class="memTemplParams" colspan="2">template&lt;typename OctreeT &gt; </td></tr>
<tr class="memitem:a3d69294f953b8a9d75526df2e30cbd3c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a0ae75653f6cec9dd7b73580a4ddba6f9">field_vec_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese_1_1visitor.html#a3d69294f953b8a9d75526df2e30cbd3c">getFieldGrad</a> (const OctreeT &amp;octree, const Eigen::Vector3f &amp;voxel_coord_f, const int scale_desired, int &amp;scale_returned)</td></tr>
<tr class="memdesc:a3d69294f953b8a9d75526df2e30cbd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the field gradient for a given coordinate [float voxel coordinates] and desired scale.  <br /></td></tr>
<tr class="separator:a3d69294f953b8a9d75526df2e30cbd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaad44fe4310d7323358d7ad8549c6ca0" name="aaad44fe4310d7323358d7ad8549c6ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad44fe4310d7323358d7ad8549c6ca0">&#9670;&#160;</a></span>getData() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OctreeT::DataType se::visitor::getData </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single/multi-res get data functions. </p>
<p>Get the voxel data for a given coordinate. The function returns init data if the data is not allocated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates to be accessed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the voxel to be accessed Returns init data if block is not allocated </dd></dl>

</div>
</div>
<a id="a8fe67985ca5372d6bb37859cb8174385" name="a8fe67985ca5372d6bb37859cb8174385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe67985ca5372d6bb37859cb8174385">&#9670;&#160;</a></span>getData() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT , typename BlockT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OctreeT::DataType se::visitor::getData </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockT *&#160;</td>
          <td class="paramname"><em>block_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the voxel data for a given coordinate. </p>
<p>The function checks first if the voxel coordinates are contained in the provided block pointer. If this is not the case the function fetches the correct block. The function returns init data if the data is not allocated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_ptr</td><td>The pointer to the block to checked first </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates to be accessed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the voxel to be accessed Returns init data if block is not allocated </dd></dl>

</div>
</div>
<a id="a4549d25ef3c1ed0d28fe2c6e3433387b" name="a4549d25ef3c1ed0d28fe2c6e3433387b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4549d25ef3c1ed0d28fe2c6e3433387b">&#9670;&#160;</a></span>getData() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, typename OctreeT::DataType &gt; se::visitor::getData </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale_desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>scale_returned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-res get data functions. </p>
<p>Get the voxel data for a given coordinate and desired scale. The function returns init data if the data is not allocated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree_ptr</td><td>The pointer to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates to be accessed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_desired</td><td>The scale to fetch the data from (init data for MultiresTSDF at node level) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_returned</td><td>The scale the data is returned from (max (scale desired, finest scale with valid data)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in octant at the returned scale </dd></dl>

</div>
</div>
<a id="ab9c872c5768c224d678d96e6f2d0a803" name="ab9c872c5768c224d678d96e6f2d0a803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c872c5768c224d678d96e6f2d0a803">&#9670;&#160;</a></span>getData() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT , typename BlockT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, typename OctreeT::DataType &gt; se::visitor::getData </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockT *&#160;</td>
          <td class="paramname"><em>block_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale_desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>scale_returned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the voxel data for a given coordinate and desired scale. </p>
<p>The function checks first if the voxel coordinates are contained in the provided block pointer. If this is not the case the function fetches the correct block. The function returns init data if the data is not allocated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_ptr</td><td>The pointer to the block to checked first </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates to be accessed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_desired</td><td>The scale to fetch the data from (init data for MultiresTSDF at node level) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_returned</td><td>The scale the data is returned from (max (scale desired, finest scale with valid data)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in octant at the returned scale </dd></dl>

</div>
</div>
<a id="a8794705cddfd87891d30f68eaa7ed59f" name="a8794705cddfd87891d30f68eaa7ed59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8794705cddfd87891d30f68eaa7ed59f">&#9670;&#160;</a></span>getMinData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::DataType::fld_==<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6ba9b4b1d446cebefa9cf1d6c6d7ef17d70">se::Field::Occupancy</a>, typename OctreeT::DataType &gt; se::visitor::getMinData </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale_desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the min occupancy data at a given scale. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of octree used (has to be of field type occupancy and multi-res) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramname">voxel_coord</td><td>The voxel coordinates in [voxel] to be accessed </td></tr>
    <tr><td class="paramname">scale_desired</td><td>The scale to be accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The min data at the requested scale. </dd></dl>

</div>
</div>
<a id="a6f5f9e987e1044adbd4481bc44af2f63" name="a6f5f9e987e1044adbd4481bc44af2f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5f9e987e1044adbd4481bc44af2f63">&#9670;&#160;</a></span>getMaxData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::DataType::fld_==<a class="el" href="namespacese.html#aabac52a9f2e0e76b7c9d505554e18c6ba9b4b1d446cebefa9cf1d6c6d7ef17d70">Field::Occupancy</a>, typename OctreeT::DataType &gt; se::visitor::getMaxData </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale_desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the max occupancy data at a given scale. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of octree used (has to be of field type occupancy and multi-res) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramname">voxel_coord</td><td>The voxel coordinates in [voxel] to be accessed </td></tr>
    <tr><td class="paramname">scale_desired</td><td>The scale to be accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The max data at the requested scale. </dd></dl>

</div>
</div>
<a id="acaa4ca4fc9c27d2d11a196dbd214b7b1" name="acaa4ca4fc9c27d2d11a196dbd214b7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa4ca4fc9c27d2d11a196dbd214b7b1">&#9670;&#160;</a></span>getField() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt; se::visitor::getField </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single/Multi-res get field functions. </p>
<p>Get the field value for a given coordinate. The function returns {}/invalid if the data is invalid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates to be accessed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The field value to be accessed if the data is valid, {}/invalid otherwise </dd></dl>

</div>
</div>
<a id="aa2fb8b7d0d89cc568532863c410b8112" name="aa2fb8b7d0d89cc568532863c410b8112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fb8b7d0d89cc568532863c410b8112">&#9670;&#160;</a></span>getField() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT , typename BlockT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt; se::visitor::getField </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockT *&#160;</td>
          <td class="paramname"><em>block_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the field value for a given coordinate. </p>
<p>The function returns {}/invalid if the data is invalid. The function checks first if the voxel coordinates are contained in the provided block pointer. If this is not the case the function fetches the correct octant.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_ptr</td><td>The pointer to the block to checked first </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates to be accessed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The field value to be accessed if the data is valid, {}/invalid otherwise </dd></dl>

</div>
</div>
<a id="ac9f41e5ef7de9af5ff1d6b7f6acab446" name="ac9f41e5ef7de9af5ff1d6b7f6acab446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f41e5ef7de9af5ff1d6b7f6acab446">&#9670;&#160;</a></span>getField() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt; &gt; se::visitor::getField </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale_desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>scale_returned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-res get field functions. </p>
<p>Get the field value for a given coordinate and desired scale. The function returns {}/invalid if the data is invalid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates to be accessed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_desired</td><td>The scale to fetch the data from (init data for MultiresTSDF at node level) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_returned</td><td>The scale the field value is returned from (max (scale desired, finest scale with valid data)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The field value at the returned scale if the data is valid, {}/invalid otherwise </dd></dl>

</div>
</div>
<a id="a7685ea5a7222975869f387aa0a82718c" name="a7685ea5a7222975869f387aa0a82718c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7685ea5a7222975869f387aa0a82718c">&#9670;&#160;</a></span>getField() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT , typename BlockT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt; &gt; se::visitor::getField </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockT *&#160;</td>
          <td class="paramname"><em>block_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale_desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>scale_returned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the field value for a given coordinate and desired scale. </p>
<p>The function returns {}/invalid if the data is invalid. The function checks first if the voxel coordinates are contained in the provided block pointer. If this is not the case the function fetches the correct octant.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_ptr</td><td>The pointer to the block to checked first </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord</td><td>The voxel coordinates to be accessed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_desired</td><td>The scale to fetch the data from (init data for MultiresTSDF at node level) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_returned</td><td>The scale the field value is returned from (max (scale desired, finest scale with valid data)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The field value at the returned scale if the data is valid, {}/invalid otherwise </dd></dl>

</div>
</div>
<a id="a60a1745b743f945af1d170e1f8fdfc7e" name="a60a1745b743f945af1d170e1f8fdfc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a1745b743f945af1d170e1f8fdfc7e">&#9670;&#160;</a></span>getInterp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT , typename ValidF , typename GetF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; std::invoke_result_t&lt; GetF, typename OctreeT::DataType &gt; &gt; &gt; se::visitor::getInterp </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidF&#160;</td>
          <td class="paramname"><em>valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetF&#160;</td>
          <td class="paramname"><em>get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>desired_scale</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *const&#160;</td>
          <td class="paramname"><em>returned_scale</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a member of <a class="el" href="classse_1_1Octree.html#a168234bec7fde15d8568c1958fd70075">se::Octree::DataType</a> at the supplied voxel coordinates and desired scale. </p>
<p>The scale the member is interpolated at may be coarser than <code>desired_scale</code> and is written in <code>returned_scale</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The multi-resolution octree containing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord_f</td><td>The voxel coordinates the member will be interpolated at. The coordinates may have a fractional part. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid</td><td>A functor with the following prototype, returning whether the supplied data is valid and should be used for interpolation: <div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OctreeT&gt;</div>
<div class="line"><span class="keywordtype">bool</span> valid(<span class="keyword">const</span> <span class="keyword">typename</span> OctreeT::DataType&amp; data);</div>
</div><!-- fragment --> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get</td><td>A functor with the following prototype, returning the member of type <code>T</code> to be interpolated: <div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OctreeT&gt;</div>
<div class="line">T get(<span class="keyword">const</span> <span class="keyword">typename</span> OctreeT::DataType&amp; data);</div>
</div><!-- fragment --> Type <code>T</code> must implement the following operators: <div class="fragment"><div class="line">T operator+(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b);</div>
<div class="line">T operator*(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span> b);</div>
</div><!-- fragment --> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desired_scale</td><td>The finest scale the member should be interpolated at. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">returned_scale</td><td>The actual scale the member was interpolated at will be stored into <code>*returned_scale</code> if <code>returned_scale</code> is non-null. <code>*returned_scale</code> is not modified if <code>std::nullopt</code> is returned. The value of <code>*returned_scale</code> will not be less than <code>desired_scale</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated member if the data is valid, <code>std::nullopt</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad6c161e98da7a59fe1a921561f4d21c4" name="ad6c161e98da7a59fe1a921561f4d21c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c161e98da7a59fe1a921561f4d21c4">&#9670;&#160;</a></span>getInterp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT , typename ValidF , typename GetF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">Res::Single</a>, std::optional&lt; std::invoke_result_t&lt; GetF, typename OctreeT::DataType &gt; &gt; &gt; se::visitor::getInterp </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidF&#160;</td>
          <td class="paramname"><em>valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetF&#160;</td>
          <td class="paramname"><em>get</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>This overload works only for single-resolution octrees. The member is interpolated at scale 0, the finest and only scale. </p>

</div>
</div>
<a id="a9fde253b575cc45d6e390c9c6fee4ca6" name="a9fde253b575cc45d6e390c9c6fee4ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fde253b575cc45d6e390c9c6fee4ca6">&#9670;&#160;</a></span>getFieldInterp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt; &gt; se::visitor::getFieldInterp </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>desired_scale</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *const&#160;</td>
          <td class="paramname"><em>returned_scale</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate the field at the supplied voxel coordinates and desired scale. </p>
<p>The scale the field is interpolated at may be coarser than <code>desired_scale</code> and is written in <code>returned_scale</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The multi-resolution octree containing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord_f</td><td>The voxel coordinates the field will be interpolated at. The coordinates may have a fractional part. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desired_scale</td><td>The finest scale the field should be interpolated at. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">returned_scale</td><td>The actual scale the field was interpolated at will be stored into <code>*returned_scale</code> if <code>returned_scale</code> is non-null. <code>*returned_scale</code> is not modified if <code>std::nullopt</code> is returned. The value of <code>*returned_scale</code> will not be less than <code>desired_scale</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated field value if the data is valid, <code>std::nullopt</code> otherwise. </dd></dl>

</div>
</div>
<a id="a9e0c95c2fc108b10e3b39475b1622bd6" name="a9e0c95c2fc108b10e3b39475b1622bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0c95c2fc108b10e3b39475b1622bd6">&#9670;&#160;</a></span>getFieldInterp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">Res::Single</a>, std::optional&lt; <a class="el" href="namespacese.html#a07837b0d4902e9209adea0266fb13c3f">field_t</a> &gt; &gt; se::visitor::getFieldInterp </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>This overload works only for single-resolution octrees. The field is interpolated at scale 0, the finest and only scale. </p>

</div>
</div>
<a id="a467b0bef5ca2d08dfe4afb004a07f130" name="a467b0bef5ca2d08dfe4afb004a07f130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467b0bef5ca2d08dfe4afb004a07f130">&#9670;&#160;</a></span>getColourInterp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a> &amp;&amp;OctreeT::col_==<a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011a521c36a31c2762741cf0f8890cbe05e3">Colour::On</a>, std::optional&lt; <a class="el" href="namespacese.html#a3773d59e592d829621175de16f791821">colour_t</a> &gt; &gt; se::visitor::getColourInterp </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>desired_scale</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *const&#160;</td>
          <td class="paramname"><em>returned_scale</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate the colour at the supplied voxel coordinates and desired scale. </p>
<p>The scale the colour is interpolated at may be coarser than <code>desired_scale</code> and is written in <code>returned_scale</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The multi-resolution octree containing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord_f</td><td>The voxel coordinates the colour will be interpolated at. The coordinates may have a fractional part. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desired_scale</td><td>The finest scale the colour should be interpolated at. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">returned_scale</td><td>The actual scale the colour was interpolated at will be stored into <code>*returned_scale</code> if <code>returned_scale</code> is non-null. <code>*returned_scale</code> is not modified if <code>std::nullopt</code> is returned. The value of <code>*returned_scale</code> will not be less than <code>desired_scale</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated colour if the data is valid, <code>std::nullopt</code> otherwise. </dd></dl>

</div>
</div>
<a id="a1f7b2de68262c0ac0867d543b344ff22" name="a1f7b2de68262c0ac0867d543b344ff22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7b2de68262c0ac0867d543b344ff22">&#9670;&#160;</a></span>getColourInterp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">Res::Single</a> &amp;&amp;OctreeT::col_==<a class="el" href="namespacese.html#ace78e3c24212aecfdeb80e7d21fab011a521c36a31c2762741cf0f8890cbe05e3">Colour::On</a>, std::optional&lt; <a class="el" href="namespacese.html#a3773d59e592d829621175de16f791821">colour_t</a> &gt; &gt; se::visitor::getColourInterp </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>This overload works only for single-resolution octrees. The colour is interpolated at scale 0, the finest and only scale. </p>

</div>
</div>
<a id="ab72fcd5a3b1c2970cd13d458004185f6" name="ab72fcd5a3b1c2970cd13d458004185f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72fcd5a3b1c2970cd13d458004185f6">&#9670;&#160;</a></span>getFieldGrad() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282da66ba162102bbf6ae31b522aec561735e">Res::Single</a>, std::optional&lt; <a class="el" href="namespacese.html#a0ae75653f6cec9dd7b73580a4ddba6f9">field_vec_t</a> &gt; &gt; se::visitor::getFieldGrad </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-res get gradient functions. </p>
<p>Get the field gradient for a given coordinate [float voxel coordinates]. The function returns {}/invalid if the gradient is invalid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord_f</td><td>The voxel coordinates to be accessed [float voxel coordiantes]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The field gradient if the gradient is valid, {}/invalid otherwise </dd></dl>

</div>
</div>
<a id="ae013c62a566800918c5dc02e364b7b06" name="ae013c62a566800918c5dc02e364b7b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae013c62a566800918c5dc02e364b7b06">&#9670;&#160;</a></span>getFieldGrad() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a0ae75653f6cec9dd7b73580a4ddba6f9">field_vec_t</a> &gt; &gt; se::visitor::getFieldGrad </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-res get gradient functions. </p>
<p>Get the field gradient for a given coordinate [float voxel coordinates]. The function returns {}/invalid if the gradient is invalid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord_f</td><td>The voxel coordinates to be accessed [float voxel coordiantes]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The field gradient if the gradient is valid, {}/invalid otherwise </dd></dl>

</div>
</div>
<a id="acd1e779a33912757222eebb642177ee1" name="acd1e779a33912757222eebb642177ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1e779a33912757222eebb642177ee1">&#9670;&#160;</a></span>getFieldGrad() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a0ae75653f6cec9dd7b73580a4ddba6f9">field_vec_t</a> &gt; &gt; se::visitor::getFieldGrad </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>scale_returned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the field gradient for a given coordinate [float voxel coordinates]. </p>
<p>The function returns {}/invalid if the gradient is invalid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord_f</td><td>The voxel coordinates to be accessed [float voxel coordiantes] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_returned</td><td>The scale the gradient has been computed at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The field gradient if the gradient is valid, {}/invalid otherwise </dd></dl>

</div>
</div>
<a id="a3d69294f953b8a9d75526df2e30cbd3c" name="a3d69294f953b8a9d75526df2e30cbd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d69294f953b8a9d75526df2e30cbd3c">&#9670;&#160;</a></span>getFieldGrad() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OctreeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; OctreeT::res_==<a class="el" href="namespacese.html#aa89d160db22d4122f886c35bf811282dace7898536dd0e928d1640ee2ad531cc8">Res::Multi</a>, std::optional&lt; <a class="el" href="namespacese.html#a0ae75653f6cec9dd7b73580a4ddba6f9">field_vec_t</a> &gt; &gt; se::visitor::getFieldGrad </td>
          <td>(</td>
          <td class="paramtype">const OctreeT &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>voxel_coord_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale_desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>scale_returned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the field gradient for a given coordinate [float voxel coordinates] and desired scale. </p>
<p>The function returns {}/invalid if the gradient is invalid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OctreeT</td><td>The type of the octree used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>The reference to the octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_coord_f</td><td>The voxel coordinates to be accessed [float voxel coordiantes] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_desired</td><td>The finest scale to compute the gradient at </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_returned</td><td>The scale the gradient has been computed at (max (scale desired, finest common neighbour scale)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The field gradient if the gradient is valid, {}/invalid otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
